<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Rust 學習筆記 - 序篇</title>
      <link href="//posts/rust-learning-prologue/"/>
      <url>//posts/rust-learning-prologue/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>因為 jserv 老師今年預計會在 <strong>Linux 系統核心課程</strong>教學 Rust，加上近幾年許多老牌 CLI 程式開始以 Rust 改寫，<br>「<strong>用 Rust 開發系統程式</strong>」似乎成為主流了，於是在傳統的 C 之外，我也決定開始學習 Rust，反正技多不壓身www<br>為了避免忘記學到的東西，並且分享學習心得，<br>我決定把學習的過程寫成文章放上來，便開始這系列的文章（<del>同時也是逼自己更新，不然我真的太容易怠惰了</del>）。</p><p>本系列文章皆參考自 <a href="https://rust-lang.tw/book-tw/">Rust 程式設計語言</a>電子書，同時會加上我在學習過程中的心得與發現。</p><h2 id="Rust-語言簡介"><a href="#Rust-語言簡介" class="headerlink" title="Rust 語言簡介"></a>Rust 語言簡介</h2><p>Rust 是以「<strong>賦權（empowerment）</strong>」為重點的程式語言，「能賦予你更多能力，在更廣泛的領域中帶有自信地向前邁進」（來自電子書<em>前言</em>）</p><p>在過去，程式語言往往會在「上層的易讀易用性」與「底層的掌控性」之間難以取捨，<br>而 Rust 對此做出挑戰，嘗試讓開發者可以控制底層的實作細節，但又能免去以往的麻煩細節。</p><p>同時，Rust 更加強調<strong>安全性</strong>、<strong>記憶體組態</strong>與<strong>並行處理</strong>，<br>這讓 Rust 程式變得更適合用於設計大型網路伺服器與客戶端、以及更安全的系統程式。</p><h2 id="Rust-適合什麼樣的人？"><a href="#Rust-適合什麼樣的人？" class="headerlink" title="Rust 適合什麼樣的人？"></a>Rust 適合什麼樣的人？</h2><p>先簡單總結：<strong>幾乎全部</strong>。</p><p>Rust 雖然重視底層實作，但同時也具備現代化的開發工具，提高開發者的生產力：</p><ul><li>Cargo：負責管理依賴函式庫與建構</li><li>Rustfmt：確保專案開發遵循統一的程式碼風格（也就是 <strong>Coding style</strong>）</li><li>Rust Language Server：提供 IDE 內的自動補全等功能</li></ul><p>所以無論是一個完整的開發團隊、公司、開源開發者甚至學生，<br>如果需要重視<strong>速度</strong>與<strong>穩定性</strong>，Rust 或許是不錯的選擇。</p><p>當然 Rust 也跟其他程式語言一樣有其缺陷：<strong>目前 Rust 並不適合用來開發 GUI 程式</strong><br>Rust 的長處在於 CLI 程式，GUI 尚在拓荒階段，並不推薦。</p><p>說到這裡，如果你也有興趣，那就跟著我開始練習吧！</p><h2 id="開始-Rust-的旅程"><a href="#開始-Rust-的旅程" class="headerlink" title="開始 Rust 的旅程"></a>開始 Rust 的旅程</h2><p>從這裡開始，我會假設大家跟我一樣有程式設計的基礎，並且有實際撰寫程式碼的經驗，<br>往後就不會再多提及程式邏輯，而是注重在 Rust 的特性與應用方式。</p><p>學習一個語言，當然要先安裝編譯器與執行環境，<br>接著就是要說明如何安裝 Rust 環境在系統上，並認識 Rust 的開發環境。</p><h2 id="安裝-Rust"><a href="#安裝-Rust" class="headerlink" title="安裝 Rust"></a>安裝 Rust</h2><p>使用及安裝 Rust 有很多方式，但新手（其實開發老手也是）強烈推薦透過 <code>rustup</code> 安裝，<br>這是一個負責管理 Rust 版本以及相關工具的 CLI 工具。</p><h3 id="安裝-rustup"><a href="#安裝-rustup" class="headerlink" title="安裝 rustup"></a>安裝 rustup</h3><h4 id="Linux-及-macOS"><a href="#Linux-及-macOS" class="headerlink" title="Linux 及 macOS"></a>Linux 及 macOS</h4><p>前往<a href="https://www.rust-lang.org/tools/install">安裝網頁</a>，會偵測你在使用的 OS，並提供你推薦的安裝方式；<br>或者直接透過以下命令下載 <code>rustup</code> 的安裝腳本並開始安裝，接著開始安裝最新穩定版本的 Rust（過程可能需要密碼）；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.3 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p>其中 <code>curl</code> 命令可以代換成 <code>wget</code> 或 <code>fetch</code>，不過通常使用 <code>curl</code> 就可以了（大多數 Linux 發行版跟 macOS 都會預裝）。<br>當出現以下訊息，代表安裝成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rust is installed now. Great!</span><br></pre></td></tr></table></figure><p>另外，Rust 在編譯資料輸出時，需要一個連結器（linker），通常會推薦使用 C 編譯器，若是遇到 linker 相關錯誤，就會需要安裝；<br>大部分的 Linux 發行版都有預裝 GCC compiler，或者依據使用習慣會是 Clang；若是沒有，請依據發行版文件安裝相關套件；<br>至於 macOS 使用者可以透過 Xcode 的工具安裝：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xocde-select --install</span><br></pre></td></tr></table></figure><p>並且，若是有使用 IDE 或任何支援 LSP 的編輯器如 Neovim，推薦額外安裝 <code>rust-analyzer</code> 這個 LSP 套件，<br>能提供更多自動補全以及整合開發的功能，目前 Rust 團隊也正在積極透過這個套件提昇對 IDE 的支援。<br>我自己是使用 Neovim，所以當然有安裝www</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>雖然我整天噴 Windows 應該被丟進太平洋最深處封印起來，但由於這東西還是有太多使用者，<br>想了想還是寫一下 Windows 的部份好了（多不甘願</p><p>同樣前往安裝網頁，應該會有個「Install Windows」等著你，依照指示安裝即可，<br>並且在 VS Code 的 Extension 商店安裝 <code>rust-analyzer</code> 套件。<br>（前述電子書是使用 Visual Studio，但因其為付費軟體就不多討論）</p><h4 id="檢查安裝"><a href="#檢查安裝" class="headerlink" title="檢查安裝"></a>檢查安裝</h4><p>Rust 的好處就是在各種 OS 指令動作都是一樣的，比較不需要特殊操作，<br>所以以下指令相容於 POSIX shell 與 cmd.exe、PowerShell。</p><p>要檢查是否正確安裝，在 shell 輸入以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><p>理論上會看到版本編號、雜湊跟提交日期，代表安裝成功；<br>若是沒有，檢查環境變數 <code>PATH</code> 是否有 Rust：<br>cmd.exe：<code>echo %PATH%</code><br>PS：<code>echo $env:PATH</code><br>Linux、macOS：<code>echo $PATH</code><br>若是有，但無法執行 Rust，就……<del>STFG</del>去社群求助吧！</p><h3 id="更新與解除安裝"><a href="#更新與解除安裝" class="headerlink" title="更新與解除安裝"></a>更新與解除安裝</h3><p><del>還沒開始寫 code 就先學怎麼解除安裝有點謎</del><br>更新 Rust 同樣透過 <code>rustup</code> 執行更新腳本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure><p>而解除安裝也是透過 <code>rustup</code> 執行解除安裝腳本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup self install</span><br></pre></td></tr></table></figure><h3 id="技術文件"><a href="#技術文件" class="headerlink" title="技術文件"></a>技術文件</h3><p>安裝 Rust 時，同時也會安裝一份本地文件，在遇上問題時可以離線閱讀；執行 <code>rustup doc</code> 即可。</p><p>都安裝好了，接著就該來寫 code 了！</p><h2 id="第一支-Rust-程式"><a href="#第一支-Rust-程式" class="headerlink" title="第一支 Rust 程式"></a>第一支 Rust 程式</h2><p>首先建議建立一個專門放 Rust 專案的目錄（每個語言都建議這麼做，避免混亂），<br>在其下建立一個 <code>hello_world</code> 目錄，在這個目錄下產生新的原始碼檔案並命名為 <code>main.rs</code>，<br>其中 <code>.rs</code> 是 Rust 的原始碼文件格式。</p><p>在這邊提一下， Rust 慣用的命名方式是 snake_case，或者比較正式的格式名稱是 <code>lowercase_separated_by_underscores</code>，<br>也就是諸如 <code>hello_world</code> 的形式。</p><p>開啟 <code>main.rs</code> 並輸入以下程式碼（部份編輯器 &#x2F; IDE 會警告「不存在 <code>Cargo.toml</code>」，此時先略過沒關係）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>儲存後回到專案目錄，編譯：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main      // Windows 上輸入 .\main.exe</span><br></pre></td></tr></table></figure><p>理論上會輸出：<br><code>Hello, world!</code><br>到這邊如果都正常，代表你成功寫出了一支 Rust 程式！</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Rust 中，所有的函式都是以 <code>fn</code> 開頭，其中 <code>fn main()</code> 是所有 Rust 程式的進入點，<br>如同 C 的 <code>main()</code>、Java 的 <code>public static void main(String[] args)</code> 等；<br>並且函式本體被放在 <code>&#123;&#125;</code> 中，如同大多數程式語言。</p><p>接著看到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>這裡需要注意的細節是：</p><ol><li>Rust 中排版風格並不是一個 tab，而是<strong>四個空格</strong>（但可以透過編輯器設定讓 tab 等於四個空格）。</li><li><code>println!</code> 是一支巨集而非函式（函式則為 <code>println</code>），目前我們只需要知道呼叫巨集是使用 <code>!</code>，且規則不完全與函式一樣。</li><li>“Hello, world!” 是字串，作為引數被傳遞給 <code>println!</code> 然後顯示在螢幕（準確來說是終端機）上，。</li><li>多數 Rust 程式碼使用分號（<code>;</code>）作為結尾（後面會學到什麼時候<strong>不該</strong>使用 <code>;</code>）。</li></ol><h3 id="編譯與執行"><a href="#編譯與執行" class="headerlink" title="編譯與執行"></a>編譯與執行</h3><p>在稍早，我們首先透過 <code>rustc</code> 編譯了 <code>main.rs</code> 並執行，<br>這意味著 Rust 如同 C、Java 等，是編譯式語言，程式碼可以編譯後將執行檔釋出給沒有安裝 Rust 的人執行。</p><p>雖然簡單的程式可以透過 <code>rustc</code> 編譯，但若是專案很大，我們就需要管理選擇並使程式碼容易分享，<br>所以接著要介紹 Rust 的好朋友——Cargo。</p><h2 id="Hello-Cargo"><a href="#Hello-Cargo" class="headerlink" title="Hello, Cargo!"></a>Hello, Cargo!</h2><p>Cargo 是 Rust 建構與管理用的工具，具有以下用途：</p><ol><li>管理專案</li><li>建構程式碼</li><li>下載並安裝依賴函式庫<br>世界上絕大多數的開發者與專案都是使用 Cargo，所以作為初學者我們也必須熟悉 Cargo，往後也會預設使用 Cargo。<br>Cargo 在前面安裝 Rust 時應該也安裝好了（若使用官方 <code>rustup</code>），可以用以下指令檢查：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br></pre></td></tr></table></figure>若是輸出版本號，代表安裝成功，接著就來學著如何用 Cargo 建立並管理專案吧！</li></ol><h3 id="使用-Cargo-建立專案"><a href="#使用-Cargo-建立專案" class="headerlink" title="使用 Cargo 建立專案"></a>使用 Cargo 建立專案</h3><p>輸入以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br><span class="line"><span class="built_in">cd</span> hello_cargo</span><br></pre></td></tr></table></figure><p>Cargo 會產生一個專案目錄，若是進入目錄並檢視會發現：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 kazan kazan  174 Feb  5 00:20 Cargo.toml</span><br><span class="line">drwxr-xr-x 2 kazan kazan 4096 Feb  5 00:20 src</span><br></pre></td></tr></table></figure><p>Cargo 產生了一個目錄：<code>src</code>（其中包含一個 <code>main.rs</code> 檔案），以及一個 <code>Cargo.toml</code> 檔案，<br>同時會將專案目錄初始化為一個 Git repository，並且新增 <code>.gitignore</code> 檔案。（如果不想要使用 git 或任何 VCS，請參考文件）</p><p>用任何編輯器開啟 <code>Cargo.toml</code>，應該會看到以下內容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>Cargo 配置文件使用 TOML，想了解更多關於 TOML，請參考<a href="https://toml.io/">官方網站</a>；<br>而其中 <code>[edition]</code> 是什麼，會在日後介紹；<br>至於 <code>[dependency]</code> 是列出專案使用哪些 dependency，在 Rust 中套件被稱為 <strong>crates</strong>，這在往後也會陸續介紹。</p><p>而 <code>main.rs</code> 被放在 <code>src</code> 下，是因為 Cargo 預期原始碼都放在 <code>src</code> 下，<br>至於根目錄是放 README、LICENSE 以及配置文件（<code>Cargo.toml</code>）等無關程式碼的檔案，讓一切井然有序。</p><h3 id="建構並執行專案"><a href="#建構並執行專案" class="headerlink" title="建構並執行專案"></a>建構並執行專案</h3><p>使用 Cargo 建構程式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 2.85 secs</span><br></pre></td></tr></table></figure><p>這指令會將執行檔輸出到 <code>target/debug</code> 目錄，因為 Cargo 預設是用 debug build，<br>接著可以仿照前面的方式執行，或是利用下面的指令一次編譯並執行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0 secs</span><br><span class="line">     Running `target/debug/hello_cargo`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>如果需要快速檢查程式碼是否能成功編譯但不想產生執行檔，可以執行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.32 secs</span><br></pre></td></tr></table></figure><h3 id="建構發布版本（Release）"><a href="#建構發布版本（Release）" class="headerlink" title="建構發布版本（Release）"></a>建構發布版本（Release）</h3><p>如果準備好要正式發布專案，可以利用 <code>cargo build --release</code>，<br>這指令會<strong>最佳化</strong>編譯結果，同時產生執行檔到 <code>target/release</code> 而非 <code>target/debug</code>；<br>最佳化編譯能夠使程式碼有更好、更快速的執行狀況，但同時需要更長的編譯時間，<br>這就是為什麼 Cargo 使用不同的設定檔：一個可以快速並經常重新建構，另一個可以產生最終釋出的版本。</p><h3 id="請將-Cargo-視為常規"><a href="#請將-Cargo-視為常規" class="headerlink" title="請將 Cargo 視為常規"></a>請將 Cargo 視為常規</h3><p>Cargo 在小型專案的優勢可能不那麼明顯，但當專案越來越大，Cargo 的用途將會越發明顯。<br>所以無論多大、多複雜的專案，都建議一律使用 Cargo 進行管理與建構。</p><p>另外，若是已存在的專案，仍然可以重新建構為一個 Cargo 專案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> example.org/someproject</span><br><span class="line">$ <span class="built_in">cd</span> someproject</span><br><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天我們學到了：</p><ol><li>如何安裝、更新 Rust</li><li>直接撰寫一支 Rust 程式</li><li><strong>使用 Cargo 建立、管理、執行 Rust 專案</strong></li></ol><p>接著沒意外是一週兩更，但會視我的進度調整（<del>簡單說就是先打拖更預防針</del>），<br>也希望能夠用這系列文章陪伴各位到開學第一個月結束（？<br>希望大家在學習的路上都能有所收穫。</p><p>火山 &#x2F; Kazan<br>2023.02.05</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux 安裝紀錄 2023</title>
      <link href="//posts/arch-install-real/"/>
      <url>//posts/arch-install-real/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>天啊上一篇竟然是兩個多月前……，我好爛喔嗚嗚嗚嗚。</p><p>經過幾個月的練習（好啦其實不需要那麼久，只是還在學期中我沒那麼多時間備份資料），趁著過年我終於做好準備，正式要跟陪伴我一年多的 Debian 說再見了。<br>（而且我是在除夕夜吃年夜飯時裝機，<del>誰能比我瘋</del>）</p><p>這次總體來說非常成功，沒有發生洗掉硬碟重來的情況，感天謝地QQ<br>以下就來簡單敘述過程吧w</p><h2 id="設備資訊"><a href="#設備資訊" class="headerlink" title="設備資訊"></a>設備資訊</h2><p>Computer: Lenovo IdeaPad 5 14ALC05<br>CPU: 12 X AMD Ryzen 5 5500U</p><h2 id="前置準備"><a href="#前置準備" class="headerlink" title="前置準備"></a>前置準備</h2><p>首先，實體裝機就需要把安裝光碟映像檔（<code>.iso</code>）寫入硬體內，考量到今日筆電大多數已經沒有光碟機，都會推薦使用 USB 隨身碟（當然也可以用 SD 卡）；<br><code>.iso</code> 檔一般都是用燒錄的方式寫入光碟，至於隨身碟，Windows 上有個好用的小工具 <a href="https://rufus.ie/zh_TW/">Rufus</a>，可以讓你把 <code>.iso</code> 映像檔燒進隨身碟，<br>不過我當時已經是在使用 Debian Linux，所以直接用 <code>dd</code> 指令寫入就可以了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=archlinux-x86_64.iso of=/dev/usb_location bs=1M</span><br></pre></td></tr></table></figure><p>再來原本的家目錄資料要<strong>備份</strong>，因為當時裝 Debian 時我並沒有另外切一塊硬碟空間掛載家目錄，而安裝時會洗掉整個硬碟（建議），<br>這花了我兩天的時間才弄好……仔細一看才發現原來我家目錄肥的要死（Orz</p><p>一切做好準備，就該開始了！</p><h2 id="裝機過程"><a href="#裝機過程" class="headerlink" title="裝機過程"></a>裝機過程</h2><p>插入安裝碟，從 UEFI 調整開機順序（USB 優先），重新開機就會進入安裝環境，<br>接著按照<a href="https://kazan.tw/posts/arch-install/">安裝筆記</a>就能成功了！<br>不過需要注意以下事項：</p><h3 id="網路連線"><a href="#網路連線" class="headerlink" title="網路連線"></a>網路連線</h3><p>VM 會用 Host 的網路連線，所以不用特別設定，但是實機要先確認網路連線，<br>筆電一般都有無線網卡，可以利用 <code>iwctl</code> 指令確認網卡與 WiFi 熱點，並進行連線：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iwtcl device list                   // List all network device</span><br><span class="line">iwctl station device get-networks   // List all available networks</span><br><span class="line">iwctl station device connect SSID   // Connect </span><br></pre></td></tr></table></figure><p>不過我自己則是用 <strong>USB 連接手機直接當作乙太網路連線</strong>啦（真的是瘋子）。</p><h3 id="Microcode"><a href="#Microcode" class="headerlink" title="Microcode"></a>Microcode</h3><p>如果使用 Intel&#x2F;AMD 這兩家的 CPU，開機管理程式 GRUB 會需要處理器的微碼（microcode），所以需要安裝相關套件，<br>在開始安裝 GRUB 前，先下載處理器微碼套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S amd-ucode     // Install microcode</span><br></pre></td></tr></table></figure><p>我使用 AMD 處理器，所以需要 AMD 的微碼套件 <code>amd-ucode</code>；反之若是使用 Intel 的就是裝 <code>intel-ucode</code>，<br>裝好之後再進行 GRUB 安裝與設定。</p><h3 id="硬碟掛載"><a href="#硬碟掛載" class="headerlink" title="硬碟掛載"></a>硬碟掛載</h3><p>這次我決定要讓根目錄與家目錄分開掛載，所以就要按照安裝筆記的分割硬碟，<br>同時要注意掛載硬碟的掛載點（Mount Point）需要指定正確，建議掛載完可以用 <code>lsblk</code> 指令檢查；<br>我在第一次指定時就不小心把 <code>/</code> 的載點指到 <code>/boot</code> 上，導致安裝失敗（空間不足），<br>當我用 <code>lsblk</code> 檢查時，發現我的第一個硬碟區塊同時載了 <code>/</code> 跟 <code>/boot</code>，這個錯誤真的蠻蠢的……</p><h3 id="輸入法"><a href="#輸入法" class="headerlink" title="輸入法"></a>輸入法</h3><p>全部安裝好之後，中文輸入一開始是使用 RIME，但我後來發現自己還是習慣新酷音（Chewing）的注音輸入，<br>所以改安裝 <code>ibus-chewing</code>，同時要啟用輸入法工具。</p><h3 id="圖形界面"><a href="#圖形界面" class="headerlink" title="圖形界面"></a>圖形界面</h3><p>因為用習慣了，加上這台筆電還算新，所以我就繼續沿用 KDE plasma：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu xorg-server plasma plasma-wayland-session kde-applications</span><br></pre></td></tr></table></figure><p>所以我的圖形界面現在還長的一模一樣XDDD</p><p>另外，在調整輸入法時一直噴掉，意外讓我發現，我的 <code>sddm</code> 竟然正在使用 <strong>Wayland</strong>，<br>只好趕快登出，在登入界面選擇 <strong>X11</strong> 的 session，差點要沒辦法打字了……</p><h3 id="AUR-Helper"><a href="#AUR-Helper" class="headerlink" title="AUR Helper"></a>AUR Helper</h3><p>AUR Helper 是什麼？請參考 Arch Wiki 的<a href="https://wiki.archlinux.org/title/Arch_User_Repository">說明</a>（全英文，<del>請自行翻譯</del>）；AUR Helper 的選擇很多，我選擇 <strong>yay</strong>（但選自己喜歡的就好），<br>在安裝之前要先啟用 pacman 的 multilib 選項，<br>找到 <code>/etc/pacman.conf</code> 並用編輯器開啟，<br>將以下兩行取消註解（刪除 #）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[multilib]</span><br><span class="line">#Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>接著需要安裝 <code>git</code>（如果已經安裝可以跳過）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure><p>然後將 yay 的原始碼 clone 到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br></pre></td></tr></table></figure><p>接著就可以編譯並安裝 yay：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><p><strong>注意：AUR Helper 不要在安裝系統時以 root 身份安裝，最好在安裝好之後以 user 權限操作</strong></p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>現在這篇文章，就是在新的 Arch Linux 上打好的！<br>Thank you Debian，但是我要投向新的懷抱了（x</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><del>不要學我想不開在除夕夜裝機（o</del><br><del>還有不要學我用手機網路還要插線（o</del></p><p>其實 Arch 裝機真的沒有很難，但就真的要習慣指令界面操作，不過我相信會用 Linux 的人肯定都會習慣的（？<br>新年新希望，祈禱換新的發行板能為我帶來新的未來。</p><p>新年恭喜，祝各位今年能夠更光明燦爛。</p><p>火山 &#x2F; Kazan<br>2023.01.30</p>]]></content>
      
      
      <categories>
          
          <category> Linux distros </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome!</title>
      <link href="//posts/welcome/"/>
      <url>//posts/welcome/</url>
      
        <content type="html"><![CDATA[<p>很高興你找到這裡了！<br>目前網站初步建置完畢，歡迎大家來這裡玩！<br>當然還有不足的地方也歡迎<a href="https://kazan.tw/contact/">聯繫我</a>給我建議！</p><p>我是火山，請多指教。</p><p>火山 &#x2F; Kazan<br>2022.09.15</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux 安裝練習筆記 2022 - BIOS+MBR</title>
      <link href="//posts/arch-install-bios/"/>
      <url>//posts/arch-install-bios/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上一篇竟然是上個月了……我果然怠惰了（跪</p><p><a href="./2022-10-arch-install.md">上次</a>練習裝機，因為目標主機用了近年主流的 UEFI+GPT，大部分東西都蠻好處理的；<br>但這次的機器很麻煩，竟然是類似傳統 DOS 機器的 <strong>BIOS+MBR</strong>（還是 2018 的機器，<del>ASUS 真的可以吃大便</del>），<br>所以很多步驟都需要更動，<br>而且那台的狀態更是慘烈，如果沒裝好可能就真的回不去了……<br>所以老樣子，用 VM 來練習裝吧！</p><p>※注意：本次安裝步驟大部分會沿用上次，只是部份步驟或設定參數有所不同，所以可以先參考上次的文章練習一次！</p><h2 id="VM-設定"><a href="#VM-設定" class="headerlink" title="VM 設定"></a>VM 設定</h2><p>跟上次一樣使用 Oracle VM VirtualBox，在新增 VM guest 的部份基本沿用上次的設定；<br>但有個不同的地方是，<br>System -&gt; Motherboard 下面<strong>不需要</strong>選擇 “Enable EFI (special OSes only)”，<br>這樣才能製造出傳統 BIOS 開機環境。</p><h2 id="Arch-安裝"><a href="#Arch-安裝" class="headerlink" title="Arch 安裝"></a>Arch 安裝</h2><p>跟上次一樣，只有少部份步驟需要調整，<br>以下就列出需要更動的地方：</p><h3 id="硬碟分割與格式化"><a href="#硬碟分割與格式化" class="headerlink" title="硬碟分割與格式化"></a>硬碟分割與格式化</h3><p>BIOS 開機不需要 <code>/boot</code> 分區，所以分割時基本上只需要主硬碟跟 Swap 分區：</p><ol><li><code>/dev/sda1</code>：分給 Swap 的部份，我大概給了 2.7 GB；格式化一樣使用 <code>mkswap</code>。</li><li><code>/dev/sda2</code>：剩下的空間都給主硬碟，一樣使用 Linux Filesystem，格式化使用 <code>mkfs.ext4</code>；另外這次我沒有分割根目錄與使用者家目錄。</li></ol><h3 id="設定套件來源"><a href="#設定套件來源" class="headerlink" title="設定套件來源"></a>設定套件來源</h3><p>這次在嘗試時不知道為什麼 <code>reflector</code> 無法正確執行，<br>所以我手動編輯了 <code>/etc/pacman.d/mirrorlist</code>，<br>另外以下直接提供台灣的鏡像列表（僅使用 https 與 IPv4）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirror.archlinux.tw/ArchLinux/$repo/os/$arch</span><br><span class="line">Server = https://free.nchc.org.tw/arch/$repo/os/$arch</span><br><span class="line">Server = https://archlinux.cs.nycu.edu.tw/$repo/os/$arch</span><br><span class="line">Server = https://ftp.yzu.edu.tw/Linux/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><h3 id="安裝開機管理程式"><a href="#安裝開機管理程式" class="headerlink" title="安裝開機管理程式"></a>安裝開機管理程式</h3><p>本次一樣使用 GRUB，但安裝參數不太一樣：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=i386-pc</span><br></pre></td></tr></table></figure><p>之後同樣生成開機設定檔即可。</p><h1 id="然後就全部照抄上次（無誤）。"><a href="#然後就全部照抄上次（無誤）。" class="headerlink" title="然後就全部照抄上次（無誤）。"></a>然後就全部照抄上次（無誤）。</h1><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>是的你沒有看錯，實際上只有這些差異而已……<br>Arch 真的蠻好玩的www，<del>還能讓我又水一篇文章（被打</del></p><p>總之，Arch 確實是一個很有趣的發行板，<br>有很多可以探索的地方，所以不如嘗試看看吧！</p>]]></content>
      
      
      <categories>
          
          <category> Linux distros </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux 安裝練習筆記 2022</title>
      <link href="//posts/arch-install/"/>
      <url>//posts/arch-install/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>Linux 有許多的發行版（distros），<br>而目前我所使用的發行版是 Debian Linux bookworm&#x2F;sid，<br>儘管已經是非常新的版本，但還是免不了 Debian 的老毛病——套件老舊；<br>加之我準備在家裡架一台 server（不論是遠端主機或 NAS 都需要一台 server），需要更穩定而先進的作業系統，<br>經過考慮與比較（<del>以及煩高秋</del>）後決定改用目前使用者社群最大的 Arch Linux。</p><p>不過 Arch 一向被認為安裝很困難，<br>連 Arch Linux 台灣社群都明言安裝是最大的難關，甚至許多老手都常在裝機時遇上麻煩，<br>所以出現不少安裝指引的文章；<br>這次的文章一方面是提供安裝的一些提醒，一方面也是幫自己留下筆記，<br>那就讓我們來看看到底要如何安裝吧！</p><h2 id="Arch-的特點"><a href="#Arch-的特點" class="headerlink" title="Arch 的特點"></a>Arch 的特點</h2><p>Arch 有四大特點：</p><ul><li>輕量</li><li>簡潔</li><li>社群活躍</li><li>漸進式升級</li></ul><h3 id="輕量"><a href="#輕量" class="headerlink" title="輕量"></a>輕量</h3><p>與其他發行板相比，Arch 並不預裝任何套件，這使得系統可以非常精簡（包含安裝映像都是），所以需要什麼都是由使用者自行決定。</p><h3 id="簡潔"><a href="#簡潔" class="headerlink" title="簡潔"></a>簡潔</h3><p>所有的函式庫、執行檔、文件、設定檔都有嚴格的路徑規範與系統管理，比較不會發生找不到設定檔的「迷路」狀況。</p><h3 id="社群活躍"><a href="#社群活躍" class="headerlink" title="社群活躍"></a>社群活躍</h3><p>雖然絕大部分發行板都是由社群維護，但 Arch 的論壇與 Wiki 可以說是世界上最知名的開源社群，因為有著大量的使用者分享經驗與知識，這使得遇上問題時，Arch 使用者第一件事會是先去查論壇、Wiki。</p><h3 id="漸進式升級"><a href="#漸進式升級" class="headerlink" title="漸進式升級"></a>漸進式升級</h3><p>Arch 採用漸進式升級（rolling upgrade），這會使得套件每天都是最新的版本，也就是說你的 Arch 每天都是 latest wwww</p><p>（本段參考自 <a href="https://archlinux.tw/">Arch Linux 臺灣社群</a>）</p><h2 id="VM-設定"><a href="#VM-設定" class="headerlink" title="VM 設定"></a>VM 設定</h2><p>本次使用的是 Oracle VM VirtualBox，<br>相信大家最近應該都知道 VirtualBox 要大改版了，不過這不是今天的重點www<br>至於用 VM 練習安裝的好處我也不再贅述，直接進入設定吧：</p><ol><li>開啟 VirtualBox，選擇 “New” 以新增 VM。</li><li>在 “Name” 打上一個名字，建議可以帶有 “arch” 字眼，VirtualBox 會自動將 “Type” 跟 “Version” 調整好。</li><li>Memory size 設定，建議至少 2 GB，但也需要考量到 Host 的記憶體大小，最好先用 <code>free -h</code> 檢查 MEM available，不要超過 available。</li><li>Hard disk 設定，這邊會設定你的虛擬硬碟，預設會是 “Create a virtual disk now” 也就是新增一個虛擬硬碟檔案，直接按下 “Create” 進入設定：<ul><li>首先會是選擇虛擬硬碟的檔案格式，建議使用預設的 VDI (VirtualBox Disk Image) 即可。</li><li>接著是選擇在實體硬碟上的儲存方式，為了避免佔用過多硬碟空間，一般都會建議選用預設的 “Dynamically allocated”（動態定址），這個方式內部是使用 CoW（Copy on Write）實作，也就是在真正寫入一個區塊時才將 VDI 檔案增大並分配空間給 VM guest。</li><li>接下來要選擇 VDI 檔案存放位置跟虛擬的硬碟大小，位置用預設就好，但大小很多人怕會佔用實體硬碟空間所以設定很小，但其實前一項才提到，VDI 配合 dynamically allocated 方式，實際上的檔案大小甚至不到 1 GB，所以大膽的給吧XD，我自己是給了 256 GB，因為太小的話屆時裝機分配給 root 的大小會不夠，就會導致後面即將提到的翻車事件……</li></ul></li><li>以上都設定完了之後，會在 VirtualBox 的 Manager 界面看到剛剛新增的 VM，但還不要高興，因為現在這樣仍然沒有開機媒體，是無法正常將 VM 「開機」的。</li><li>請先準備好 Arch 的安裝碟映像檔（.iso），接著按下 VM 管理界面的 “Settings”，檢查並調整以下細節：<ul><li>System<ul><li>Motherboard<ul><li>Extended Features: 請選擇 “Enable EFI (special OSes only)”</li></ul></li><li>Processor<ul><li>Processor(s): 4 CPUs，建議至少 2 CPUs</li></ul></li></ul></li><li>Display<ul><li>Screen<ul><li>Video Memory: 使用預設即可。</li></ul></li></ul></li><li>Storage<ul><li>Controller: IDE<br>  這裡是重點，預設會是 “Empty”，點選 “Empty”，並按下 “Optical Drive” 旁邊的小圖示，選擇事先準備好的 .iso 檔案，並勾選 “Live CD&#x2F;DVD”。</li></ul></li></ul></li><li>以上設定都沒有問題後，啟動 VM，進入以下畫面就代表設定成功，我們要開始裝機地獄囉（幹<br><img src="/posts/arch-install/vm1.png" alt="vm1"></li></ol><h2 id="Arch-安裝"><a href="#Arch-安裝" class="headerlink" title="Arch 安裝"></a>Arch 安裝</h2><p>VM 啟動後，開機選單會有很多選項，直接選第一個就好；<br>接著等待以下畫面出現，就代表我們可以開始安裝了：<br><img src="/posts/arch-install/install1.png" alt="install1"></p><p>你可能會問：「怎麼是文字界面？所以我可以直接用了嗎？」或是「怎麼沒有跳出安裝指示？」，<br>這就是為什麼 Arch 被認為安裝很難的原因：<strong>需要自己透過指令界面操作才能安裝系統，沒有圖形安裝界面。</strong><br>沒關係，接下來我會一步一步告訴大家該怎麼做！</p><h3 id="網路測試"><a href="#網路測試" class="headerlink" title="網路測試"></a>網路測試</h3><p>因為 Arch 的安裝映像是<strong>最小安裝</strong>，會需要網路下載所需套件，所以在開始之前一定要測試好網路連線。<br>使用 <code>ping</code> 指令測試網路功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping archlinux.org</span><br></pre></td></tr></table></figure><p>如果顯示如下圖，即可以按下 Ctrl+C 中斷並進入下一步：<br><img src="/posts/arch-install/install2.png" alt="install2"><br>這邊因為使用的是 VM，理論上網路連線不會有大問題，有的話就是你動到設定了（o</p><h3 id="硬碟分割、格式化與掛載"><a href="#硬碟分割、格式化與掛載" class="headerlink" title="硬碟分割、格式化與掛載"></a>硬碟分割、格式化與掛載</h3><p>安裝一個新系統最重要的就是分割硬碟跟格式化了！<br><em><strong>特別注意：檔案系統的格式會很大程度影響你的安裝與日後使用，特別是實機上務必謹慎操作！</strong></em></p><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><p>如果要分割硬碟，目前有很多種套件可以操作，最常見是用 <code>fdisk</code>，<br>但我個人喜歡用 <code>cfdisk</code>，因為有 UI 而且很直覺，且分割是以 size 而不是 sector 作為參考：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk</span><br></pre></td></tr></table></figure><p><img src="/posts/arch-install/install3.png" alt="install3"><br>如上圖，選擇 “gpt” 後，顯示如下就可以開始分割：<br><img src="/posts/arch-install/install4.png" alt="install4"><br>用 “New” 並輸入磁碟大小以新增分割區，並且使用 “Type” 選擇檔案系統格式（很重要！），最後記得每個分割區都要用 “Write” 寫入，才不會做白工。</p><p>至於分割方式可以參考如下：</p><ol><li><code>/dev/sda1</code>：使用 EFI system，作為開機碟（<code>/boot</code>）使用，基本上給 256 MB 就足夠了，當然如果你的硬碟上本來就有開機磁區就可以略過。</li><li><code>/dev/sda2</code>：使用 Linux Filesystem，作為根目錄（<code>/</code>）使用，<strong>請務必給大一點以便能安裝套件</strong>；因為是 VM 所以可以給更大一點，我會給到 128 GB。（分配太小會導致安裝套件時高機率發生裝不下，我曾經設了 16 GB 結果下面裝字體就硬碟塞爆了……）</li><li><code>/dev/sda3</code>：使用 Linux Filesystem，預計會作為家目錄（<code>/home</code>）使用，先計算好下面的 Swap 空間，剩下就都留給這邊，我給了 123 GB。</li><li><code>/dev/sda4</code>：使用 Linux swap，作為置換分區（Swap），類似 Windows 的 pagefile；當然如果 RAM 足夠可以不給，並且也可以在安裝完成後設定 swap file。這邊建議給跟記憶體大小差不多，我給了 4.7 GB。</li></ol><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>硬碟分割完成後，還需要格式化才能被識別，<br>首先格式化兩個主要的儲存碟為 <code>ext4</code> 格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda2</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure><p>接著要格式化開機碟為 <code>FAT32</code> 格式才能使用 EFI system 開機，當然如果本來就有就可以略過：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F 32 /dev/sda1</span><br></pre></td></tr></table></figure><p><em>提醒：這個指令的輸出只有顯示一行 <code>mkfs.fat</code> 的版本編號是正常的，不必擔心。</em><br>然後格式化 swap：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda4</span><br></pre></td></tr></table></figure><h4 id="掛載"><a href="#掛載" class="headerlink" title="掛載"></a>掛載</h4><p>硬碟分割跟格式化之後，別忘了掛載到系統上才能被使用！<br>如果有出現找不到路徑的警告，就先 <code>mkdir -p &lt;dir&gt;</code> 建立目錄再回來掛載：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br><span class="line">mount /dev/sda3 /mnt/home</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br></pre></td></tr></table></figure><p>另外 swap 也要啟用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda4</span><br></pre></td></tr></table></figure><p>這些都做完了，終於要正式進入系統安裝的部份了！</p><h3 id="設定套件來源"><a href="#設定套件來源" class="headerlink" title="設定套件來源"></a>設定套件來源</h3><p>什麼又是設定？<br>沒事只差一步了不要緊張，這個沒有設定好就可能會看到美麗的 “request time out” 喔&lt;3</p><p>為什麼要設定來源？簡單來說，今天我在台灣，但是套件從德國下載，你覺得下載套件會快嗎？<br><strong>當然慢到在地上爬啊別作夢了www</strong><br>所以設定優先順序還是非常重要的，<br>這邊有兩種方式提供，這次選用是用第二種：</p><h4 id="手動修改-mirrorlist"><a href="#手動修改-mirrorlist" class="headerlink" title="手動修改 mirrorlist"></a>手動修改 mirrorlist</h4><p>用官方提供的<a href="https://archlinux.org/mirrorlist/">鏡像站列表</a>，把在台灣的鏡像寫入 <code>/etc/pacman.d/mirrorlist</code> 並給予優先序，就這樣（？</p><h4 id="利用套件自動生成"><a href="#利用套件自動生成" class="headerlink" title="利用套件自動生成"></a>利用套件自動生成</h4><p>可以利用 <code>reflector</code> 這個套件生成最佳排序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install reflector</span></span><br><span class="line">pacman -Sy reflector</span><br><span class="line"><span class="comment"># Generate mirrorlist</span></span><br><span class="line">reflector --verbose -l 5 --<span class="built_in">sort</span> rate --country <span class="string">&#x27;Taiwan&#x27;</span> --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>完成這些設定後，我們真的要開始執行「安裝」了。</p><h3 id="安裝系統"><a href="#安裝系統" class="headerlink" title="安裝系統"></a>安裝系統</h3><h4 id="系統核心"><a href="#系統核心" class="headerlink" title="系統核心"></a>系統核心</h4><p>首先要安裝基本的套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure><p>這行指令會下載並安裝、建立基本系統架構。</p><p>接著是建立 fstab，<br>這個東西提供了 Linux 檔案系統的相關資訊，描述了儲存裝置及其相關磁區如何初始化，與掛載至整個系統，<br>所以非常重要！如果沒有設定好，之後開機肯定會噴掉：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>然後，重頭戲來了：<strong>切換至 chroot</strong>。<br><code>chroot</code> 是切換根目錄位置的指令，在這邊是要切換進入「未來」真正的檔案系統以進行設定，<br>並且 Arch 安裝時使用的是 <code>arch-chroot</code>，除了前述的動作還會帶入前置的設定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p><strong>提醒大家，<code>chroot</code> 指令要有目標路徑，不然不會動作喔！</strong><br>（<del>我不會承認我在這邊因為忘記打翻車十幾次……</del>）</p><p>切換到新系統之後，為了要讓這個系統成為一個可以獨立運作的作業系統，<br>我們要安裝對於所有 Linux 發行版而言最重要的東西——<strong>Linux kernel</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure><p><strong>特別注意：安裝核心務必在 chroot 內進行！</strong>（<del>我曾經在 chroot 外就下了安裝核心的指令，然後就翻車了ㄏㄏ</del>）</p><h4 id="設定-root-與-user"><a href="#設定-root-與-user" class="headerlink" title="設定 root 與 user"></a>設定 root 與 user</h4><p>一般來說一個 Linux 的系統裡面會有 root 與至少一個使用者（user），<br>在日常的使用、操作會以 user 身份進行，遇到重大系統操作才需要切換到 root 身份，<br>這是一種基本的系統安全。</p><p>首先我們設定 root 的密碼：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p><em>提醒：大部分的終端機界面輸入密碼是什麼都不會顯示的，所以若你輸入後看到畫面上沒有任何字元不需要緊張喔！</em></p><p>接著要啟用 sudo group，這是為了以後一般 user 可以進行套件安裝等日常操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>找到類似下面這行，刪除 “#” 以取消註解：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %wheel ALL=(ALL) ALL</span></span><br></pre></td></tr></table></figure><p>（什麼你說你不會用 vim？<del>STFG</del>vim 教學網路上很多喔&lt;3）</p><p><em>注意：如果顯示錯誤「沒有 vim」，可以先安裝 vim 再重新執行：</em></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim</span><br></pre></td></tr></table></figure><p>然後就是新增 user 並給予 sudo 權限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add new user</span></span><br><span class="line">useradd -m &lt;username&gt;</span><br><span class="line"><span class="comment"># Set user&#x27;s password</span></span><br><span class="line">passwd &lt;username&gt;</span><br><span class="line"><span class="comment"># Give user sudo</span></span><br><span class="line">usermod &lt;username&gt; -aG wheel</span><br></pre></td></tr></table></figure><h4 id="安裝開機管理程式"><a href="#安裝開機管理程式" class="headerlink" title="安裝開機管理程式"></a>安裝開機管理程式</h4><p>使用 UEFI 的話開機管理預設會使用 <code>systemd-boot</code>，但我喜歡用 GRUB，<br>所以要來安裝跟設定 GRUB 啦！</p><p><em>注意：如果是實機，並且是 Intel&#x2F;AMD 處理器的話，需要先下載 microcode，不過這次是 VM 就先略過了。</em></p><p>首先當然是要下載所需套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure><p>接著安裝 grub：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>安裝好 GRUB 後，還要記得生成開機設定檔，屆時才會讓 Arch 出現在開機選單上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h4 id="啟用網路連線功能"><a href="#啟用網路連線功能" class="headerlink" title="啟用網路連線功能"></a>啟用網路連線功能</h4><p>網路連線我個人習慣使用 <code>NetworkManager</code>，<br>並且我在這邊也翻車過一次，特別拿出來筆記一下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S networkmanager</span><br></pre></td></tr></table></figure><p>下載與安裝後，因為 NM 是個<strong>服務</strong>，需要在系統內啟用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> NetworkManager.service</span><br><span class="line">systemctl start NetworkManager.service</span><br></pre></td></tr></table></figure><p>到這邊其實你已經有一個堪用的 Arch Linux 了，<br>但大部分人還是習慣有圖形界面的桌面環境，所以接著就是來裝桌面環境吧！</p><h3 id="桌面環境"><a href="#桌面環境" class="headerlink" title="桌面環境"></a>桌面環境</h3><p>在 Linux 上，一個堪用的桌面環境至少會有一個 DE 與 DM，<br>DE 是桌面環境，而 DM 則是<del>廣告傳單</del>桌面環境管理（Desktop Manager），<br>主流兩大 DE：GTK+ Gnome 跟 KDE plasma 都有自己的 DM，<br>但這次我打算使用的是輕量簡潔但已經具備基本桌面環境功能的 XFCE，<br>並且配合使用 LightDM 作為 DM。</p><h4 id="安裝-XFCE"><a href="#安裝-XFCE" class="headerlink" title="安裝 XFCE"></a>安裝 XFCE</h4><p>XFCE 建議使用 X11 作為協定，所以除了 XFCE 的套件群組，還需要安裝 <code>xorg-server</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg-server</span><br><span class="line">pacman -Sy xfce4</span><br></pre></td></tr></table></figure><h4 id="安裝-LightDM"><a href="#安裝-LightDM" class="headerlink" title="安裝 LightDM"></a>安裝 LightDM</h4><p>一個 DM 除了能執行桌面環境，還要有一些基本的登入登出功能，<br>這邊我使用推薦的 <code>lightdm-gtk-greeter</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure><p>然後測試 LightDM 能不能正常運作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start lightdm.service</span><br></pre></td></tr></table></figure><p>如果有出現圖形登入界面如下代表應該可以正常運作，<br><img src="/posts/arch-install/install5.png" alt="install5"><br>先以 <strong>user</strong> 登入並直接關機。（右上角選單應該有 Shutdown 選項）</p><h3 id="重新啟動測試"><a href="#重新啟動測試" class="headerlink" title="重新啟動測試"></a>重新啟動測試</h3><p>VM 關機後，可以先嘗試移除安裝媒體（映像檔）並再次啟動 VM，<br>如果開機選單有出現 “Arch Linux”，代表 Arch 安裝成功！<br>接著如果正常應該會是終端機登入界面如下圖：<br><img src="/posts/arch-install/install6.png" alt="install6"><br>此時先以 root 登入，並且正式啟用圖形界面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> lightdm.service</span><br></pre></td></tr></table></figure><p>啟用之後重新啟動（<code>reboot</code>），應該就能看到登入界面囉！</p><h3 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h3><p>進入桌面環境後，先開啟終端機（這邊設定也可以先在上一步啟動 LightDM 前先設定），並設定以下資訊：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set timezone and NTP</span></span><br><span class="line">sudo timedatectl set-timezone Asia/Taipei</span><br><span class="line">sudo timedatectl set-ntp <span class="literal">true</span></span><br><span class="line"><span class="comment"># Set locale</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;en_US.UTF-8 UTF-8&quot;</span> &gt;&gt; /etc/locale.gen</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;zh_TW.UTF-8 UTF-8&quot;</span> &gt;&gt; /etc/locale.gen</span><br><span class="line">locale-gen</span><br><span class="line">localectl set-locale en_US.UTF-8</span><br><span class="line"><span class="comment"># Set hostname</span></span><br><span class="line">sudo hostnamectl set-hostname &lt;your-host-name&gt;</span><br></pre></td></tr></table></figure><p>設定完成後可以「登出」再重新登入，理論上可以看到更動後的系統設定<br><em>注意：關於語系的設定，也可以直接編輯 <code>/etc/locale.gen</code>，在裡面取消對應語系的註解即可。</em></p><h3 id="安裝中文輸入法與字體"><a href="#安裝中文輸入法與字體" class="headerlink" title="安裝中文輸入法與字體"></a>安裝中文輸入法與字體</h3><p>如果需要中文輸入法與字體，需要額外安裝喔！</p><h4 id="輸入法"><a href="#輸入法" class="headerlink" title="輸入法"></a>輸入法</h4><p>這邊我們使用 RIME：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install RIME and zhuyin-input-method</span></span><br><span class="line">pacman -S ibus ibus-rime rime-bopomofo</span><br><span class="line"><span class="comment"># Set Ibus</span></span><br><span class="line">ibus-setup</span><br></pre></td></tr></table></figure><p>此時應該會跳出提示，確認後會跳出 Ibus 的設定視窗，<br>在 “Input method” 的 tab 內按下 “Add”，選擇 “Chinese”，並選擇 RIME；<br>然後在家目錄下新增一個檔案 <code>.xprofile</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=ibus</span><br><span class="line">export XMODIFIERS=@im=ibus</span><br><span class="line">export QT_IM_MODULE=ibus</span><br><span class="line">ibus-daemon -x -d</span><br></pre></td></tr></table></figure><p>儲存後再次重啟，檢查輸入法有沒有 RIME 中文即可。</p><h4 id="字體"><a href="#字體" class="headerlink" title="字體"></a>字體</h4><p>字體選用許多人都愛用的 Noto-fonts，並且中文 &#x2F; 亞洲字體是 Noto-CJK，加上 emoji：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br></pre></td></tr></table></figure><p>理論上登出再登入應該就可以使用了。<br><img src="/posts/arch-install/install_final.png" alt="install_final"><br>現在你應該得到一個非常基本的、可以方便操作的 Arch Linux 了，<br>剩下就是安裝你需要的套件，學習如何使用 Arch！</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>本次文章跟安裝的過程，<br>大部份是參考了高手我朋友<a href="https://www.fanlan.net/">繁嵐</a>寫的<a href="https://www.fanlan.net/arch-linux-installation-note/index.html">安裝筆記</a>，配合高秋每天被我<del>騷擾</del>討教，<br>終於在昨天成功的安裝到可以使用的狀態了（泣<br>裝了快兩週才終於成功一次，我真的佩服自己的毅力……</p><p>不過第一次嘗試這種安裝的模式其實很有趣，會更了解一點作業系統的架構與運作，<br>也有不少「意外之喜」，<br>相信之後裝 NixOS 肯定會有更多驚喜呢（棒讀</p><p>接下來，要來想我要用 Arch 做什麼事情，之後沒意外大概會有好幾篇文章在紀錄吧。<br>說不定明年鐵人賽主題就是這個了（幹</p><p>火山 &#x2F; Kazan<br>2022.10.17</p>]]></content>
      
      
      <categories>
          
          <category> Linux distros </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim 設定 - 外觀篇</title>
      <link href="//posts/nvim-setting-awesome/"/>
      <url>//posts/nvim-setting-awesome/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><del>斷更快一週我很抱歉（</del></p><p>上次我們利用外掛設定了基本的 LSP 跟自動完成功能，<br>不過用著用著就想好像少了些什麼？</p><p>然後高秋看到就吐嘈我說：你為什麼直接用終端機界面，不設定個主題？<br>還有你不覺得有個狀態列的提示你工作會比較方便嗎？<br>我才恍然大悟，原來這種終端機界面的純文字編輯器還有這麼多有趣的外掛！</p><p>於是這兩天在一邊作業翻車的情況下，我又開始了設定<del>（ㄊㄧㄠˊ ㄐㄧㄠˋ）</del>之旅，<br>花了一整天終於搞定以下的「玩具」（？</p><p>以下就是一些簡單的紀錄。</p><h2 id="背景主題"><a href="#背景主題" class="headerlink" title="背景主題"></a>背景主題</h2><p>我選用了 <a href="https://github.com/EdenEast/nightfox.nvim">Nightfox</a> 這個外掛，有很多主題選項，這邊我採用是淺色底的 Dayfox。<br><img src="https://user-images.githubusercontent.com/2746374/158456281-e8a968c0-e282-4943-b919-3d8454ca0529.png" alt="Dayfox"><br>(Source: GitHub README)</p><h2 id="狀態欄"><a href="#狀態欄" class="headerlink" title="狀態欄"></a>狀態欄</h2><p>我用了 <a href="https://github.com/nvim-lualine/lualine.nvim">lualine</a>，然後改了一些顯示的設定讓他比較乾淨一點</p><h2 id="Tabline"><a href="#Tabline" class="headerlink" title="Tabline"></a>Tabline</h2><p>其實 Neovim 並沒有真正的頁籤（tab），只是把 buffer 當成 tab 的顯示形式。<br>這邊使用了 <a href="https://github.com/akinsho/bufferline.nvim">bufferline</a>，<br>接著就在這裡翻車了（幹</p><h2 id="字體"><a href="#字體" class="headerlink" title="字體"></a>字體</h2><p>結果我發現 lualine 跟 bufferline 出現了一些沒有正常顯示的字元，<br>查了 README 發現這些外掛使用了 <a href="https://github.com/kyazdani42/nvim-web-devicons">nvim-web-devicons</a>，如果要正常顯示，本機上需要有安裝可用的 patched font，但我並沒有安裝，<br>後來就選擇了 <a href="https://www.nerdfonts.com/">Nerd fonts</a> 裡面的 Inconsolata，順便也把終端機跟 VS Code 的字體改了，<br>之後終於可以正常顯示了！\灑花&#x2F;</p><h2 id="File-Explorer"><a href="#File-Explorer" class="headerlink" title="File Explorer"></a>File Explorer</h2><p>你以為純文字編輯器就沒有檔案瀏覽嗎？<br><a href="https://github.com/kyazdani42/nvim-tree.lua">nvim-tree.lua</a> 是你的好朋友www<br><img src="https://github.com/kyazdani42/nvim-tree.lua/raw/master/.github/screenshot.png?raw=true" alt="nvim-tree"><br>(Source: GitHub README)</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>蛤你說我沒教怎麼裝外掛？<br>給我去看 Neovim 設定的<a href="https://kazan.tw/posts/nvim-setting/">前一篇</a>！</p><p>Neovim 還有很多好玩的外掛，我想我以後還有得研究了w</p><p>火山 &#x2F; Kazan<br>2022.10.07</p>]]></content>
      
      
      <categories>
          
          <category> Technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neovim </tag>
            
            <tag> Editors </tag>
            
            <tag> Plug-ins </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>良好的 Coding style</title>
      <link href="//posts/coding-style/"/>
      <url>//posts/coding-style/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上一篇聊到同學們 code 的排版造成我很嚴重的視力及心理傷害（無誤），<br>這篇正好來聊聊一個好的 coding style 是什麼吧！</p><p><em><strong>注意：本篇所有論點皆屬個人見解，若不認同請保持理性討論。</strong></em></p><h2 id="什麼是-coding-style？"><a href="#什麼是-coding-style？" class="headerlink" title="什麼是 coding style？"></a>什麼是 coding style？</h2><p>Coding style 指的是「程式碼的『寫作』風格」，<br>如同一般的文章風格一樣，程式碼的寫作風格也會因人而異，<br>小至空格的使用、大括號 <code>&#123;&#125;</code> 的位置，大至函式的宣告、語法的選擇都會有不同的個人風格。</p><p><strong>那為什麼要強調「好的」coding style？</strong></p><p>如果初學程式設計的人，可能會在教材上看到大部分高階程式語言有個特性——「可讀性」，<br>也就是容易閱讀、容易理解，這也造就了現代的開發協作環境。<br>但我個人認為這樣的特性需要配合良好的撰寫習慣才能發揮到最大，<br>特別是在幫別人 debug 的時候，如果你看到一個雜亂無章、文字過度集中的程式碼，<br>真的會跟我一樣眼睛很痛（o</p><p>以下是我覺得很重要的幾個各語言都通用的 coding style：</p><h3 id="空格與段落"><a href="#空格與段落" class="headerlink" title="空格與段落"></a>空格與段落</h3><p>首先給各位看個範例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個看起來很正常的程式碼有什麼問題呢？</p><p>先不急著解答，我們來看看另一個人寫的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有發現細微的差異了嗎？<br>沒錯，就是<strong>「適當的空格與段落」</strong>。</p><p>在絕大部分語言中，運算子、參數之間的空格，以及分隔段落的空行並非必要，<br>編譯 &#x2F; 直譯器最後都會把這些空格 &#x2F; 行無視掉，<br>那為什麼還要加這些東西增加行數？（關於程式碼行數這又是另一個故事了）</p><p><strong>因為雖然機器看得懂，但人也要看得懂跟舒服啊。</strong></p><p>上面兩個程式碼拿給任一個人看，大多數都會說後者看起來比較舒服，<br>也會比較有耐心（？）幫忙 debug，這說明<strong>沒有適度的排版確實會影響閱讀體驗</strong>；<br>簡單說，你今天要拜託人看程式碼，結果因為你寫得很醜反而讓對方很困擾，<br>這不是造成人家更麻煩、你自己也更麻煩嗎？<br>如同寫字一樣，寫程式碼最基本的就是整齊易讀。</p><p>最後給各位看個非常極端的案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> arr_size,target;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr_size);</span><br><span class="line"><span class="type">int</span>* <span class="built_in">list</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *<span class="built_in">list</span>*arr_size);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr_size;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="built_in">list</span>+i));&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line"><span class="type">int</span> tar_index=binSearch(<span class="built_in">list</span>,target,<span class="number">0</span>,arr_size<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tar_index);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"><span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,left,middle,right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,arr[left],arr[middle],arr[right]);</span><br><span class="line"><span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line"><span class="keyword">switch</span>(compare(arr[middle],target))&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">return</span> binSearch(arr,target,middle+<span class="number">1</span>,right);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> binSearch(arr,target,left,middle<span class="number">-1</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>如果能堅持看完全部的人我佩服你</del></p><h3 id="變數、函數、類別的命名"><a href="#變數、函數、類別的命名" class="headerlink" title="變數、函數、類別的命名"></a>變數、函數、類別的命名</h3><p>這是更多初學者會犯的錯誤——變數<strong>胡亂命名</strong>或是<strong>命名無意義</strong>。</p><p>常常會在一些小朋友寫的程式碼裡面看到諸如 <code>int a, b</code> 之類的命名滿街跑，<br>每次在 debug 都要問好多次「這變數是要存什麼」、「這個 function 是在做什麼」、「這類別是什麼東西」，<br>問到最後甚至會得到這樣的回應：「呃我忘了耶。」<del>忘記了你還叫我 debug？我不會通靈啊ㄍ！</del></p><p>一個好的命名，是能夠讓人一目瞭然這東西的用途，進而可以更快的發現問題所在；<br>一個壞的命名，可能會讓你自己都搞不清楚這在幹嘛，結果就是程式 bug 一大堆，然後你也不知道從何處理。</p><p>所以什麼是好的命名方式？</p><h4 id="1-有意義的名稱"><a href="#1-有意義的名稱" class="headerlink" title="1. 有意義的名稱"></a>1. 有意義的名稱</h4><p>舉個例子：<br>當你的程式需要儲存一筆「金額」的資料，一般人可能就 <code>int a</code> ，<br>最多用註解告訴大家這個 <code>a</code> 是放金額的變數，但誰知道 <code>a</code> 跟金額的關聯？！<br><del>如果在 debug 的時候絕對會聽到以下哀號：「這 a 是在幹嘛啊啊啊（無限慘叫）？」</del><br>所以用有意義的名稱命名是很重要的！<br>以上面的例子，命名為 <code>int mount</code> 會是比較好的做法；若是需要，也可以組合兩個甚至以上的「名詞」作為命名。<br>但也不是所有單字都可以用，盡量避免使用以下的字詞：</p><ul><li>語言保留字（如 Python <code>input</code>）</li><li>單一動詞，通常也會是保留字</li><li>無意義的單字，容易造成干擾（<code>temp</code> 之類的）</li><li>無意義的前綴<br>另外也要避免命名過長，否則溝通上會有困難。</li></ul><h4 id="2-大小寫識別"><a href="#2-大小寫識別" class="headerlink" title="2. 大小寫識別"></a>2. 大小寫識別</h4><p>有意義的名稱固然重要，但若是全部都大寫或全部都小寫，其實也是有缺點的，<br>因為仍然會造成閱讀及識別上的困難。<br>例如：<code>int arraysize</code> 這是個有意義的組合命名，但是不容易閱讀。<br>所以一般在命名時會建議如下：</p><ul><li>變數、函式 &#x2F; 方法：小寫開頭，以底線連結如 <code>first_name</code>（此即 snake case），或是第二個單字首字母大寫如 <code>lastName</code>（即「<strong>駝峰式命名法</strong>」）。</li><li>常數：全部大寫，如 <code>PI = 3.14</code>、<code>MAX_SIZE</code></li><li>類別：大寫開頭，如 <code>Display</code>、<code>Phone</code></li></ul><h4 id="3-命名一致"><a href="#3-命名一致" class="headerlink" title="3. 命名一致"></a>3. 命名一致</h4><p>這裡的一致指的是「定義一致」，也就是對單一對象的定義；<br>舉例：定義使用者叫 <code>user</code>，那有關的其他命名也要以 <code>user</code> 為主，如使用者的存款可以叫 <code>userBalance</code>，<br>不要變成 <code>accountBalance</code> ，否則會造成一定程度的混亂。</p><h4 id="4-術語正確"><a href="#4-術語正確" class="headerlink" title="4. 術語正確"></a>4. 術語正確</h4><p>這沒什麼好說的，就是用正確的專業術語，否則會造成極大的混淆。</p><h3 id="建立-coding-convention"><a href="#建立-coding-convention" class="headerlink" title="建立 coding convention"></a>建立 coding convention</h3><p>說了這麼多，最重要的是建立一個 coding 的慣例（convention），並且整份專案都要遵守這個慣例，<br>這在多人合作的專案中更為重要，否則大家都用自己的方式寫，<br>結果就是會造成每個人都不知道其他人在寫什麼，最後整合的時候就會大混亂。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><del>好的 coding style 帶你上天堂，壞的 coding style 讓你住套房</del></p><p>寫出一份漂亮的 code 不只對自己維護專案方便，也能讓別人在幫助你的時候更加輕鬆，<br>所以何不從現在開始練習，養成良好的 coding style 吧！</p><p>火山 &#x2F; Kazan<br>2022.09.27</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構 - 二元搜尋</title>
      <link href="//posts/binary-search/"/>
      <url>//posts/binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>這星期資結終於上機了，上週直接爽放一天假期ww<br>不過這周一上課就是混沌地獄，一堆人直接忘記 C 怎麼寫……（助教：完蛋了之後更難我豈不是忙死）<br>有人直接問怎麼輸入資料……連 <code>scanf()</code> 都忘記了嗎（尖叫<br><del>至於 VLA（<code>int array[n]</code>）跟 code 不排版就算了吧（點菸</del></p><p>慣例的廢話就到這邊，接著來聊聊這周的題目——二元搜尋法吧。</p><h2 id="基本知識"><a href="#基本知識" class="headerlink" title="基本知識"></a>基本知識</h2><p>一般我們在一串資料中要搜尋特定的一筆資料，直覺的方式就是從頭開始一筆筆比對，也就是所謂的線性搜尋，<br>但這樣需要花費的可能時間會非常的長，如果目標在最後一筆就會找非常久；<br>二元搜尋法則是利用「中間值」的概念，在一串已經<strong>排序過</strong>的資料中，每次都比對一定範圍的「中間」索引，<br>若不是目標資料的話則以中間值與其中一端為範圍，即縮小一半的搜尋區間，<br>然後不斷循環這樣的搜尋方式，直到找到目標。<br>這個方法相較於線性搜尋的好處是，搜尋的可能時間最壞會指數減少，<br>以演算法要求的時間複雜度而言，這是一個較好的解決方案。</p><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><ul><li><em>輸入：輸入一個陣列長度，並依序輸入整數陣列資料，最後輸入一個搜尋目標。</em></li><li><em>輸出：每一輪搜尋都輸出兩行，第一行為左右邊界及中間值的索引值，第二行為對應的資料；若最後有找到目標資料，輸出其索引值。</em></li><li><em><strong>注意：只能使用 C 或 C++，並請使用「遞迴」方式搜尋；另外本次的測資都是「可以找到目標」，不需要考慮找不到的情形。</strong></em></li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>這邊就用我們的老朋友 C 來實作（C++？對不起我們不熟）。</p><h3 id="注意-VLA"><a href="#注意-VLA" class="headerlink" title="注意 VLA"></a>注意 VLA</h3><p>首先建立一個陣列，這邊許多初學者會犯的錯誤是 VLA（Variable Length Array，可變長度陣列），其實以安全性來說是非常不安全的。<br>什麼是 VLA？顧名思義，就是陣列的長度是可以更改的，如下列程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;          <span class="comment">// 一堆人都用這個宣告大小我已經懶得吐嘈了</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[n];   <span class="comment">// 使用變數宣告陣列大小</span></span><br></pre></td></tr></table></figure><p>你或許會問，長度可變不好嗎？陣列有彈性不是好事嗎？<br>但這樣宣告的問題在於，記憶體容易發生 stack overflow（<del>不是我們常常抄 code 那個</del>），<br>因為記憶體就是配置在一個固定大小的 stack，所以若是 <code>n</code> 太大就會爆掉。</p><p>如果真的需要陣列長度保持彈性，或者陣列大小依賴輸入值，<br>請務必使用<strong>動態記憶體</strong>分配的方式，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">// 務必要寫這行，因為 malloc() 是定義在這個標頭檔裡面的</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> *<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size);   <span class="comment">// 動態宣告記憶體配置</span></span><br></pre></td></tr></table></figure><p>上述宣告是基本使用 <code>malloc()</code> 的方式，但其實還可以修改成 <code>int* array = malloc(sizeof *array * size)</code>，<br>這樣若是陣列型態有變化，比較不會發生左邊改了但右邊忘記改的囧況。</p><h3 id="二元搜尋算法"><a href="#二元搜尋算法" class="headerlink" title="二元搜尋算法"></a>二元搜尋算法</h3><p>建立好陣列跟輸入資料，並且取得目標資料後，就是要考慮算法。</p><p>前面提到二元搜尋的方式是利用「區間中間值」，所以我們首先要考慮中間值的位置，<br>若陣列長度是奇數那就很簡單，但若是偶數，就需要定義中間值是哪一個，<br>一般我們會定義中間兩數取較小的為中間值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> middle = (left + right) / <span class="number">2</span>;     <span class="comment">// left 是左區間，right 是右區間</span></span><br></pre></td></tr></table></figure><p>這邊不 - 1 是因為 C 的 <code>/</code> 運算在兩數皆為整數時只會取整數的商值，例如 <code>9 / 2</code> 得到的會是 <code>4</code> 而不是 <code>4.5</code>，<br>正好會符合前面所述取中間兩數較小者。</p><p>接著就是進行比對，如果一次就中當然幸運，直接回傳索引值；<br>但不是的時候肯定要進行下一輪比對，直到找到為止。<br>一般想法就是用迴圈跑，但這次題目要求用遞迴，那該怎麼寫？</p><h3 id="使用遞迴"><a href="#使用遞迴" class="headerlink" title="使用遞迴"></a>使用遞迴</h3><p>遞迴的寫法其實並沒有很複雜，比對過大小後，若不是目標就再次呼叫搜尋函式，不過會有兩種情形：</p><ol><li>目標資料比中間資料大</li><li>目標資料比中間資料小</li></ol><p>這兩種情形傳入函式的引數會不太一樣。</p><h4 id="目標資料比中間資料大"><a href="#目標資料比中間資料大" class="headerlink" title="目標資料比中間資料大"></a>目標資料比中間資料大</h4><p>代表目標資料索引在目前中間值的<strong>右邊</strong>，所以將<strong>中間值 + 1</strong> 作為新的<strong>左</strong>區間。</p><h4 id="目標資料比中間資料小"><a href="#目標資料比中間資料小" class="headerlink" title="目標資料比中間資料小"></a>目標資料比中間資料小</h4><p>代表目標資料索引在目前中間值的<strong>左邊</strong>，所以將<strong>中間值 - 1</strong> 作為新的<strong>右</strong>區間。</p><p>這邊用 switch-case 的方式判斷：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &lt;= right) &#123;     <span class="comment">// 因為資料排序過，應該是左區間小於右區間，若不是則整個函式回傳 -1</span></span><br><span class="line">    <span class="keyword">switch</span> (compare(<span class="built_in">array</span>[middle], target)) &#123;   <span class="comment">// 比對目標與中間值，compare() 是另外宣告的比大小函式</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:    <span class="comment">// 目標比中間值大</span></span><br><span class="line">            <span class="keyword">return</span> search(<span class="built_in">array</span>, target, middle + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">// 中間值即是目標</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     <span class="comment">// 目標比中間值小</span></span><br><span class="line">            <span class="keyword">return</span> search(<span class="built_in">array</span>, target, left, middle <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最終結果"><a href="#最終結果" class="headerlink" title="最終結果"></a>最終結果</h3><p>執行結果需要輸出每一次搜尋的左右區間跟中間值的「索引值」與「資料內容（數字）」，<br>因為每搜尋一次就要印一次，所以這個程序在每次呼叫搜尋函式就應該要被執行，故千萬不要寫在判斷式內，<br>而是輸出後再執行比對的判斷式；<br>最後找到目標資料後要將索引值單獨輸出一行，我自己的作法是將輸出的程序寫在主函式（<code>int main()</code>）裡面，<br>理由是我認為這個程序是在上述「搜尋」的函式以外的動作，所以我只讓搜尋函式在找到目標後回傳其索引給主函式，<br>而在主函式則設定一個變數接收最後回傳的索引值，並接著輸出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> targetIndex = search(<span class="built_in">array</span>, targer, <span class="number">0</span>, arraySize - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, targetIndex);</span><br></pre></td></tr></table></figure><p>將以上組合就是這次的結果了。</p><h2 id="結論與討論"><a href="#結論與討論" class="headerlink" title="結論與討論"></a>結論與討論</h2><p>這次終於不是我翻車了，但換來的是看到一堆令人吐血的慘烈 code（幹</p><p>其實二元搜尋真的沒有很難，這次我大約花半小時就完成，當然以高手的角度還是很慢了；<br>不過我主要是想檢討幾個能更好的地方：</p><h3 id="1-沒用指標"><a href="#1-沒用指標" class="headerlink" title="1. 沒用指標"></a>1. 沒用指標</h3><p>其實在 C 裡面善用指標能使執行效率有效提昇，因為電腦其實更認得記憶體位址而不是單純索引或是變數，<br>但我指標其實還需要補強（我因為指標被當過……），希望在學期結束前能更為熟練。</p><h3 id="2-沒有處理例外情況"><a href="#2-沒有處理例外情況" class="headerlink" title="2. 沒有處理例外情況"></a>2. 沒有處理例外情況</h3><p>雖然題目是說不會有找不到的情況，<br>但一個好的程式設計應該要設想到大部分的例外情況並處理，而不是放著讓程式噴 error；<br>搜尋函式其實在找不到的情況應該會回傳一個 <code>-1</code>，可以從這個地方切入去想想怎麼處理，<br>在看了許多高手的文章後，大部分會尋找一個近似值，之後我應該會找時間實作一下。</p><blockquote><p>在每次的實作與錯誤（<del>ㄈㄢ ㄔㄜ</del>）中都能發現自己的不足並且檢討，<br>才能不斷進步，否則以後會繼續在同樣的地方跌倒。</p></blockquote><p>最後預告一下，下一篇我可能不會寫技術實作，而是來聊聊所謂 coding style，<br>這次真的被某些同學嚇到了……</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim 設定</title>
      <link href="//posts/nvim-setting/"/>
      <url>//posts/nvim-setting/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上一篇文章的最後我提到學任何語言首先要先調教好編輯器，<br>這是源自於我那天還沒開始寫任何 code，就先花了半天的時間在處理 Neovim 的設定，特別是 LSP 的設定真的差點搞死我……<br>乾脆寫一篇來紀錄跟分享這個過程。<br><del>我是不是要感謝我的笨拙跟容易翻車讓我常常有題材可以寫文章</del></p><h2 id="為什麼是純文字編輯器"><a href="#為什麼是純文字編輯器" class="headerlink" title="為什麼是純文字編輯器"></a>為什麼是純文字編輯器</h2><p>或許有人會問：「現在新式的 IDE 像是 VS Code 界面漂亮而且使用方便，為什麼還要用純文字編輯器？」<br>這有很多可以說的面向，而且每個人的理由也不盡相同，<br>我自己的話是想要挑戰看看純文字編輯器的功能是不是真的不如 IDE、以及單純覺得好玩（o<br>當然專案開發我自己還是以 IDE 為主，因為視覺化的看專案檔真的比較輕鬆一點。<br>（BTW，雖然我前天 Java 是用 Neovim 寫的，<br>但強者我朋友 a.k.a. 清大怪物高秋表示「Java『專案』」是他數一數二推薦用 IDE 進行開發的語言，<br>因為純用 command line 會很煩躁）</p><h2 id="為什麼是-Neovim"><a href="#為什麼是-Neovim" class="headerlink" title="為什麼是 Neovim"></a>為什麼是 Neovim</h2><p>純文字編輯器主流分成兩大系譜：emacs 跟 vi，那為什麼我選擇了 vi 這支而不是 emacs 系？<br><del>因為 emacs 東西太多了，多到我會尖叫 too much 那種多（關於這個我不打算寫，我會逼高秋寫），</del><br>vi 系的好處，或者說優勢是在 terminal 上比較便利，emacs 只有 GUI 版比較好用，<br>如果想嘗試終端機界面 coding，用 vi 系的體驗會比較好；<br>至於選擇 Neovim 是因為 plug-in 的生態比較活躍，<br>並且自行撰寫 plug-in 也比較容易<del>，這是個 plug-in 的<a href="https://www.youtube.com/watch?v=1FliVTcX8bQ">新時代</a></del>。</p><h2 id="Neovim-設定調教"><a href="#Neovim-設定調教" class="headerlink" title="Neovim 設定調教"></a>Neovim 設定<del>調教</del></h2><p>好我花太多篇幅寫為什麼了，趕快進入正題（（（</p><p>先把 Neovim 安裝好（怎麼安裝？去搜尋！），接著要來改一下設定檔囉～</p><h3 id="init-vim"><a href="#init-vim" class="headerlink" title="init.vim"></a>init.vim</h3><p>這是 Neovim 的全域設定檔，通常應該在 <code>~/.config/nvim/</code> 之下，<br>然後隨便開個編輯器來改設定就好了w</p><p>一開始的 <code>init.vim</code> 應該會看到幾乎每一行開頭都是雙引號 <code>&quot;</code>，<br>這是由於 Neovim 本身預設是用 vimscript 來寫相關設定，在這個語言中 <code>&quot;</code> 是註解（就像 C 裡面的 <code>//</code> 一樣）；<br>不過現在主流是使用 Lua 語言來寫設定跟 plug-in ，所以該怎麼辦呢？</p><p><strong>那就自己寫一個 Lua 設定就好啦！</strong></p><h3 id="Lua-設定檔"><a href="#Lua-設定檔" class="headerlink" title="Lua 設定檔"></a>Lua 設定檔</h3><p>首先在剛剛的 <code>~/.config/nvim/</code> 下新增一個 <code>lua</code> 目錄，<br>在 <code>lua</code> 裡面建立一個設定的 <code>.lua</code> 檔案（這邊取名 <code>setups.lua</code>），<br>然後以下是範例檔案（至於需要加上什麼請參考各 plug-in 說明文件）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---nvim-lsp-installer</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;nvim-lsp-installer&quot;</span>).setup &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">---nvim-cmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cmp = <span class="built_in">require</span><span class="string">&#x27;cmp&#x27;</span></span><br><span class="line"></span><br><span class="line">cmp.setup(&#123;</span><br><span class="line">  snippet = &#123;</span><br><span class="line">    <span class="comment">-- REQUIRED - you must specify a snippet engine</span></span><br><span class="line">    expand = <span class="function"><span class="keyword">function</span><span class="params">(args)</span></span></span><br><span class="line">      <span class="comment">-- vim.fn[&quot;vsnip#anonymous&quot;](args.body) -- For `vsnip` users.</span></span><br><span class="line">      <span class="built_in">require</span>(<span class="string">&#x27;luasnip&#x27;</span>).lsp_expand(args.body) <span class="comment">-- For `luasnip` users.</span></span><br><span class="line">      <span class="comment">-- require(&#x27;snippy&#x27;).expand_snippet(args.body) -- For `snippy` users.</span></span><br><span class="line">      <span class="comment">-- vim.fn[&quot;UltiSnips#Anon&quot;](args.body) -- For `ultisnips` users.</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  window = &#123;</span><br><span class="line">    <span class="comment">-- completion = cmp.config.window.bordered(),</span></span><br><span class="line">    <span class="comment">-- documentation = cmp.config.window.bordered(),</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mapping = cmp.mapping.preset.<span class="built_in">insert</span>(&#123;</span><br><span class="line">    [<span class="string">&#x27;&lt;C-b&gt;&#x27;</span>] = cmp.mapping.scroll_docs(<span class="number">-4</span>),</span><br><span class="line">    [<span class="string">&#x27;&lt;C-f&gt;&#x27;</span>] = cmp.mapping.scroll_docs(<span class="number">4</span>),</span><br><span class="line">    [<span class="string">&#x27;&lt;C-Space&gt;&#x27;</span>] = cmp.mapping.complete(),</span><br><span class="line">    [<span class="string">&#x27;&lt;C-e&gt;&#x27;</span>] = cmp.mapping.abort(),</span><br><span class="line">    [<span class="string">&#x27;&lt;CR&gt;&#x27;</span>] = cmp.mapping.confirm(&#123; <span class="built_in">select</span> = <span class="literal">true</span> &#125;), <span class="comment">-- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.</span></span><br><span class="line">  &#125;),</span><br><span class="line">  sources = cmp.<span class="built_in">config</span>.sources(&#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;nvim_lsp&#x27;</span> &#125;,</span><br><span class="line">    &#123; name = <span class="string">&#x27;vsnip&#x27;</span> &#125;, <span class="comment">-- For vsnip users.</span></span><br><span class="line">    <span class="comment">-- &#123; name = &#x27;luasnip&#x27; &#125;, -- For luasnip users.</span></span><br><span class="line">    <span class="comment">-- &#123; name = &#x27;ultisnips&#x27; &#125;, -- For ultisnips users.</span></span><br><span class="line">    <span class="comment">-- &#123; name = &#x27;snippy&#x27; &#125;, -- For snippy users.</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;buffer&#x27;</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set configuration for specific filetype.</span></span><br><span class="line">cmp.setup.filetype(<span class="string">&#x27;gitcommit&#x27;</span>, &#123;</span><br><span class="line">  sources = cmp.<span class="built_in">config</span>.sources(&#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;cmp_git&#x27;</span> &#125;, <span class="comment">-- You can specify the `cmp_git` source if you were installed it.</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;buffer&#x27;</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Use buffer source for `/` (if you enabled `native_menu`, this won&#x27;t work anymore).</span></span><br><span class="line">cmp.setup.cmdline(<span class="string">&#x27;/&#x27;</span>, &#123;</span><br><span class="line">  mapping = cmp.mapping.preset.cmdline(),</span><br><span class="line">  sources = &#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;buffer&#x27;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Use cmdline &amp; path source for &#x27;:&#x27; (if you enabled `native_menu`, this won&#x27;t work anymore).</span></span><br><span class="line">cmp.setup.cmdline(<span class="string">&#x27;:&#x27;</span>, &#123;</span><br><span class="line">  mapping = cmp.mapping.preset.cmdline(),</span><br><span class="line">  sources = cmp.<span class="built_in">config</span>.sources(&#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;path&#x27;</span> &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &#123; name = <span class="string">&#x27;cmdline&#x27;</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Set up lspconfig.</span></span><br><span class="line"><span class="keyword">local</span> capabilities = <span class="built_in">require</span>(<span class="string">&#x27;cmp_nvim_lsp&#x27;</span>).update_capabilities(vim.lsp.protocol.make_client_capabilities())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- nvim-lspconfig</span></span><br><span class="line"><span class="comment">-- Mappings.</span></span><br><span class="line"><span class="comment">-- See `:help vim.diagnostic.*` for documentation on any of the below functions</span></span><br><span class="line"><span class="keyword">local</span> opts = &#123; noremap=<span class="literal">true</span>, silent=<span class="literal">true</span> &#125;</span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;space&gt;e&#x27;</span>, vim.diagnostic.open_float, opts)</span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;[d&#x27;</span>, vim.diagnostic.goto_prev, opts)</span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;]d&#x27;</span>, vim.diagnostic.goto_next, opts)</span><br><span class="line">vim.keymap.set(<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;&lt;space&gt;q&#x27;</span>, vim.diagnostic.setloclist, opts)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Use an on_attach function to only map the following keys</span></span><br><span class="line"><span class="comment">-- after the language server attaches to the current buffer</span></span><br><span class="line"><span class="keyword">local</span> on_attach = <span class="function"><span class="keyword">function</span><span class="params">(client, bufnr)</span></span></span><br><span class="line"><span class="comment">---- Enable completion triggered by &lt;c-x&gt;&lt;c-o&gt;</span></span><br><span class="line"><span class="comment">--vim.api.nvim_buf_set_option(bufnr, &#x27;omnifunc&#x27;, &#x27;v:lua.vim.lsp.omnifunc&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---- Mappings.</span></span><br><span class="line"><span class="comment">---- See `:help vim.lsp.*` for documentation on any of the below functions</span></span><br><span class="line"><span class="comment">--local bufopts = &#123; noremap=true, silent=true, buffer=bufnr &#125;</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;gD&#x27;, vim.lsp.buf.declaration, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;gd&#x27;, vim.lsp.buf.definition, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;K&#x27;, vim.lsp.buf.hover, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;gi&#x27;, vim.lsp.buf.implementation, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;C-k&gt;&#x27;, vim.lsp.buf.signature_help, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wa&#x27;, vim.lsp.buf.add_workspace_folder, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wr&#x27;, vim.lsp.buf.remove_workspace_folder, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;wl&#x27;, function()</span></span><br><span class="line">  <span class="comment">--print(vim.inspect(vim.lsp.buf.list_workspace_folders()))</span></span><br><span class="line"><span class="comment">--end, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;D&#x27;, vim.lsp.buf.type_definition, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;rn&#x27;, vim.lsp.buf.rename, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;ca&#x27;, vim.lsp.buf.code_action, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;gr&#x27;, vim.lsp.buf.references, bufopts)</span></span><br><span class="line"><span class="comment">--vim.keymap.set(&#x27;n&#x27;, &#x27;&lt;space&gt;f&#x27;, vim.lsp.buf.formatting, bufopts)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lsp_flags = &#123;</span><br><span class="line"><span class="comment">---- This is the default in Nvim 0.7+</span></span><br><span class="line"><span class="comment">--debounce_text_changes = 150,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;lspconfig&#x27;</span>).jdtls.setup&#123;</span><br><span class="line"><span class="comment">--on_attach = on_attach,</span></span><br><span class="line"><span class="comment">--flags = lsp_flags,</span></span><br><span class="line">capabilities = capabilities,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至於這些是什麼東西？<br>稍後會挑重點講解。</p><h3 id="vim-plug-設定"><a href="#vim-plug-設定" class="headerlink" title="vim-plug 設定"></a>vim-plug 設定</h3><p>接著回到 <code>init.vim</code>，我們要先安裝 plug-in 管理，<br>目前主流有兩種使用 plug-in 的方式：</p><ol><li>packer.vim</li><li>vim-plug</li></ol><p>這次我使用了 vim-plug，至於怎麼安裝 vim-plug 並且加入 plug-in ，<br>可以參考另一個強者我朋友 SimbaFs 寫的<a href="https://ithelp.ithome.com.tw/articles/10273424">這篇文章</a>，這邊不多加贅述。</p><p>確定 vim-plug 安裝成功後，<br>就可以在兩個 <code>call plug</code> 中間的區塊（見前述文章）加入你要的 plug-in 了。</p><h3 id="LSP-plug-ins"><a href="#LSP-plug-ins" class="headerlink" title="LSP plug-ins"></a>LSP plug-ins</h3><p>終於要來設定重點的 LSP 了，沒有 LSP 你用 Neovim 就等於用記事本而已（o）<br>首先在上述區塊中加入這行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;neovim/nvim-lspconfig&#x27;</span><br></pre></td></tr></table></figure><p>這個負責執行 LSP server，<br>接著如果你的 Neovim 是 0.7.0 以後的版本（現在大部份發行板的 <code>latest</code> 都過了吧），<br>就可以安裝 <code>williamboman/nvim-lsp-installer</code> 這個 plug-in，可以直接在指令列下 <code>:LspInstall</code> 安裝 LSP server：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;williamboman/nvim-lsp-installer&#x27;</span><br></pre></td></tr></table></figure><p>接下來是與自動完成相關的 plug-in，前兩者建議一定要安裝，<br>第三個端看你 <code>setups.lua</code> 中 expand 選擇什麼，因為我選擇了 <code>luasnip</code>，所以就是安裝這個：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;hrsh7th/nvim-cmp&#x27;</span><br><span class="line">Plug &#x27;hrsh7th/cmp-nvim-lsp&#x27;</span><br><span class="line">Plug &#x27;L3MON4D3/LuaSnip&#x27;</span><br></pre></td></tr></table></figure><p>儲存修改後，開啟 Neovim，直接下 <code>:PlugInstall</code> 指令，會根據 <code>init.vim</code> 的內容安裝，<br>安裝成功就可以先下 <code>:q</code> 關閉。</p><h3 id="使用-setups-lua"><a href="#使用-setups-lua" class="headerlink" title="使用 setups.lua"></a>使用 setups.lua</h3><p>在稍早我們新增了一個名為 <code>.config/nvim/lua/setups.lua</code> 的檔案，<br>接下來就是要讓 <code>init.vim</code> 使用這個檔案進行設定。</p><p>在 <code>call plug#end()</code> 下面新增一行 <code>lua require(&#39;setups&#39;)</code>，<br><strong>注意引號內要寫的是 lua 設定檔的檔名（不要照抄！）</strong>，<br>儲存後可以開啟 Neovim，沒有噴 Error 就是成功了。<br><del>然後就不需要再碰 vimscript 了。</del></p><p>所以這個檔案到底是什麼東西？<br>簡單來說是把 plug-in 的設定都寫進來，讓 Neovim 自己去讀取，<br>大部分設定都不用改（有興趣可以去研究看看XD），這邊要特別提及的是兩個區塊：</p><ol><li><code>cmp.setup()</code> 裡面的 <code>expand</code> 部份</li><li>最下面 <code>require</code> 的部份</li></ol><h4 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expand = <span class="function"><span class="keyword">function</span><span class="params">(args)</span></span></span><br><span class="line">  <span class="comment">-- vim.fn[&quot;vsnip#anonymous&quot;](args.body) -- For `vsnip` users.</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;luasnip&#x27;</span>).lsp_expand(args.body) <span class="comment">-- For `luasnip` users.</span></span><br><span class="line">  <span class="comment">-- require(&#x27;snippy&#x27;).expand_snippet(args.body) -- For `snippy` users.</span></span><br><span class="line">  <span class="comment">-- vim.fn[&quot;UltiSnips#Anon&quot;](args.body) -- For `ultisnips` users.</span></span><br><span class="line"><span class="keyword">end</span>,</span><br></pre></td></tr></table></figure><p>這邊是放自動完成格式的 plug-in，平行的四行是讓你選擇其一（<del>記得要安裝不然會像我一樣翻車</del>），<br>至於安裝方式就是找到 GitHub repo，以 <code>Plug &#39;author/repo_name&#39;</code> 的方式寫入 <code>init.vim</code> 並安裝，<br>其他不需要的就是註解掉（在 Lua 裡面是使用 <code>--</code>）。</p><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;lspconfig&#x27;</span>).jdtls.setup&#123;</span><br><span class="line"><span class="comment">--on_attach = on_attach,</span></span><br><span class="line"><span class="comment">--flags = lsp_flags,</span></span><br><span class="line">capabilities = capabilities,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊是設定 LSP server 的自動完成，跟上面 <code>expand</code> 都有設定才是完整的自動完成。<br>把 <code>jdtls</code> 的部份代換成你要的 LSP server 就可以了（至於有哪些可以用請參考官方文件）；<br>有複數個 server 就如法炮製複製同樣的段落。</p><p>好啦，現在應該是可以開心的當 IDE 來寫程式囉（？），<br>如果要檢查有沒有正常運作可以開啟原始碼檔案，指令輸入 <code>:LspInfo</code> 檢查，<br>沒有問題就可以舒舒服服的 coding 啦！</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>如果真的很懶還是請用 IDE，第一次操作你一定會想放棄（ｏ<br>不過花半天設定完看到可以正常運作的時候還是會很感動的。</p><p>另外提醒如果是用 Java 的 <code>jdtls</code>，請務必注意 OpenJDK 版本要是最新的（目前是 <code>openjdk-17-jre</code>），<br>不然 LSP 還是不會動的喔&lt;3（受害者辛酸發言）</p><p>如果想挑戰自我的真的可以玩看看純文字編輯器，<br>你會發現新大陸www</p><p>火山 &#x2F; Kazan<br>2022.09.21</p>]]></content>
      
      
      <categories>
          
          <category> Technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neovim </tag>
            
            <tag> Editors </tag>
            
            <tag> LSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 實作 Stack - 使用陣列</title>
      <link href="//posts/20-java-stack/"/>
      <url>//posts/20-java-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><del>先吐嘈老師根本喪心病狂w</del></p><p>昨天物件導向正式上課跟上機（雖然我都上自己的機），<br>一開始老師簡單介紹了 Java 基本操作，畢竟這年頭 Java 不是必修課（？）；<br>然後就出了三個作業：（萬年不變的）Hello world、運算子運用，<br>最後一個就是今天的主角：<strong>實作 Stack</strong>。</p><p>如果說有學過 Java 可能會知道，<code>java.util</code> 有個 package 叫 <code>Stack</code> 就是用來實作 stack 的，<br>但老師笑容可掬的說：「<strong>請用 array 實作喔。</strong>」<br>差點在教室尖叫。</p><h2 id="基本知識"><a href="#基本知識" class="headerlink" title="基本知識"></a>基本知識</h2><p>Stack &#x2F; 堆疊，顧名思義就是把資料「堆」上去的結構，所以有以下特性：</p><ol><li>先進後出 &#x2F; 後進先出（<strong>LIFO, Last In First Out</strong>）</li><li>除了頭尾外的每個節點都有「前綴」與「後繼」</li></ol><p>對於 stack 的操作通常有以下兩種方法：</p><ul><li>push：將資料存入 stack 頂端</li><li>pop：將 stack 頂端資料移除，頂端移到下一筆資料</li></ul><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><em>請以一維陣列實作 stack，其中元素（elements）儲存於 <code>stack[0]</code> 到 <code>stack[top]</code> 之間。</em></p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>這次除了實作 stack 的操作，<br>還要實作顯示頂端資料（<code>top()</code>）、判斷 stack 是否為滿（<code>isFull()</code>）或空（<code>isEmpty()</code>）、pop 全部資料（<code>popall()</code>），<br>一開始想說把資料頂端定義為 stack[0]，但發現用以前學 C 的概念會讓自己寫出一堆無用跟充滿 bug 的程式碼，<br>後來發現自己題目沒看清楚（見「題目」），才發現頂端是 <code>stack[top]</code>，<br>所以可以設定一個頂端索引值（<code>top</code>），並初始為 <code>-1</code> 讓操作較為輕鬆。<br><del><strong>這告訴我們題目一定要看清楚。</strong></del></p><h3 id="判斷是否為滿或空"><a href="#判斷是否為滿或空" class="headerlink" title="判斷是否為滿或空"></a>判斷是否為滿或空</h3><ul><li><code>isFull()</code>：stack 如果滿的時候，<code>top</code> 值會等於 4（因為大小設為 5，故堆滿時頂端索引為 5 - 1 &#x3D; 4），故判斷 <code>top</code> 是否等於 <code>MAX_STACK_SIZE - 1</code> 即可。</li><li><code>isEmpty()</code>：stack 裡面沒有資料時，<code>top</code> 會小於 0（詳見 <code>pop()</code> 實作），故僅需要判斷 <code>top</code> 是否小於 0 即可判斷。</li></ul><h3 id="Stack-push"><a href="#Stack-push" class="headerlink" title="Stack push"></a>Stack push</h3><p>先判斷 stack 是不是已經堆滿，若是則警告；否則就將元素放入頂端。<br>放入的方式必須遵循 LIFO 的原則（不然就不是 stack 了），<br>故 push 進去的資料在陣列中索引值一定是 <code>top</code>，<br>而初始 stack 為空時 <code>top</code> 是 -1，所以一開始要先讓它成為 0（<code>++top</code>），<br>後續 push 進去的索引則依序增加。</p><h3 id="Stack-pop"><a href="#Stack-pop" class="headerlink" title="Stack pop"></a>Stack pop</h3><p><code>pop()</code> 方法是要「取出」頂端的資料，<br>所以先判斷 stack 是否為空（不然沒資料怎麼 pop？），接著將頂端索引值 -1 即可（<code>top--</code>），<br>這是因為沒有索引就等於存取不到資料，「形同」刪除資料。（這樣比較容易理解啦w）</p><h3 id="顯示頂端資料"><a href="#顯示頂端資料" class="headerlink" title="顯示頂端資料"></a>顯示頂端資料</h3><p>同 <code>pop()</code>，需要先判斷 stack 是否為空（沒資料顯示個鬼），接著存取頂端的資料並印出。</p><h3 id="pop-全部資料"><a href="#pop-全部資料" class="headerlink" title="pop 全部資料"></a>pop 全部資料</h3><p>這部份要求連續顯示頂端資料並且 pop 該筆資料，直到 stack 為空；<br>既然已經有 <code>pop()</code> 方法就不需要另外刻一個 pop 資料的 feature，<br>直接利用迴圈跑 <code>pop()</code> 就可以了www，迴圈判斷就是檢查 stack 是否為空，若空（isEmpty() &#x3D;&#x3D; true）則停止迴圈。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><del>首先你得先調教好你的編輯器</del>（應該下一篇文章會來聊這件事）</p><p>用 Java 實作資料結構的體驗還蠻新鮮的，雖然其實我資料結構還沒開始上課（o）；</p><p>然後學習資料結構的過程其實蠻有趣的，會讓以前寫 procedure function 的壞習慣減少很多，<br>能夠用更簡潔與快速的方式對資料進行操作，不只 code 會乾淨漂亮，維護也比較容易。</p><p>老師預告下週會用物件的概念實作 stack，屆時再來看看有什麼不同之處吧！</p><p>火山 &#x2F; Kazan<br>2022.09.20</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網站基礎架構</title>
      <link href="//posts/16-site-intro/"/>
      <url>//posts/16-site-intro/</url>
      
        <content type="html"><![CDATA[<p>第一篇正式文章，來談談這個網站是怎麼產生的吧！</p><h2 id="網域"><a href="#網域" class="headerlink" title="網域"></a>網域</h2><p>網域一開始是想用 Freenom 的免費網域，但他們不給新註冊了QQ，<br>後來想既然我是台灣人，就用 <code>.tw</code> 的網域好了，然後就去跟 HiNet 買了（800 元好貴）。<br>後面 DNS 之類的就丟給 Cloudflare 託管了，還順便弄了自己的 mail address（<del>真香</del>）。</p><h2 id="架站工具選擇"><a href="#架站工具選擇" class="headerlink" title="架站工具選擇"></a>架站工具選擇</h2><p>你說 WordPress？<br>CMS 是很方便啦但還要多設定 WordPress 需要的 domain 設定之類的，<br>嫌麻煩就決定用一般常用的 SSG。</p><p>至於 SSG 的選擇，<br>最一開始想選擇 Hugo，但部署我覺得很麻煩就放棄了；<br>後來又改成 Django，再來又轉成 Vite + Vue3，但這兩個都是 App 式，檔案跟網站架構我有點無法理解，也就相繼放棄掉。<br>最後是看很多人推薦選擇了 Hexo，用下去驚為天人（？）</p><h2 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h2><p>就預設的 <code>landscape</code> 啊，還是大家有推薦的主題可以讓我參考www</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>最方便的選擇就是 GitHub Pages 囉XD，<del>雖然我也有 Netlify 之類的就是了</del>。<br>而且大部分的 SSG 官方文件其實都有提供 GitHub Pages 的部屬流程，算是蠻友善的w</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>大概就是，懶人設定？<br>雖然中間過程我也是被很多設定搞到唉唉叫，<br>（還發生過動到設定結果 <code>hexo g</code> 產生靜態檔案時渲染爆炸，所有頁面都一片白……）<br>不過最終成果還是很滿意的！</p><p>目前還需要改進的是：</p><ol><li>文章不夠多（我努力三天生一篇啦QQ）</li><li>除了文章的頁面還可以更多樣一些</li><li>要找人幫我作主視覺了，banner 是用預設的，favicon 甚至是拿 Google Material 的火山圖示wwww</li><li>首頁的呈現我想改，但 <code>landscape</code> 的 layout 我有點看不懂，有大神願意教學嗎QQ</li></ol><p>目前大概就這樣，想到再補充XD<br>這邊慣例附上各個工具的使用版本或是提供者：</p><ul><li>Hexo：6.3.0</li><li>Hexo-cli：4.3.0</li><li>Node.js：18.7.0</li><li>Domain name provider：HiNet domain</li><li>DNS hosting：Cloudflare</li><li>Theme：Hexo-landscape</li></ul><p>火山 &#x2F; Kazan<br>2022.09.16</p>]]></content>
      
      
      <categories>
          
          <category> technical </category>
          
      </categories>
      
      
        <tags>
            
            <tag> infra </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
