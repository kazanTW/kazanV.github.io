<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Rust 學習筆記第四章 - 結構體 | Kazan&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前情提要上次我們已經大略討論完 Rust 最重要的概念：所有權，這次要討論的則是結構體（structure），是很常見的資料結構。如果學過 C&#x2F;C++ 大概會很有印象。 結構體結構體與元組類似，兩者都可以擁有多種數值，但結構體的每個資料部份都需要被命名以表達意義；這同時允許我們不用依賴資料的順序存取結構體實例的值。 如果要定義結構體，使用 struct 關鍵字並命名，然後在 &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust 學習筆記第四章 - 結構體">
<meta property="og:url" content="http://kazan.tw/posts/rust-learning-part4/">
<meta property="og:site_name" content="Kazan&#39;s Home">
<meta property="og:description" content="前情提要上次我們已經大略討論完 Rust 最重要的概念：所有權，這次要討論的則是結構體（structure），是很常見的資料結構。如果學過 C&#x2F;C++ 大概會很有印象。 結構體結構體與元組類似，兩者都可以擁有多種數值，但結構體的每個資料部份都需要被命名以表達意義；這同時允許我們不用依賴資料的順序存取結構體實例的值。 如果要定義結構體，使用 struct 關鍵字並命名，然後在 &amp;#123;">
<meta property="og:locale" content="zh_TW">
<meta property="article:published_time" content="2023-02-19T20:13:00.000Z">
<meta property="article:modified_time" content="2023-02-22T06:35:42.241Z">
<meta property="article:author" content="Kazan @ Kazan Studio">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Kazan's Home" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kazan&#39;s Home</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">敗北の少年、平凡を謳え</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/cal">Calender</a>
        
          <a class="main-nav-link" href="/contact">Contact</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜尋"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜尋"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kazan.tw"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-rust-learning-part4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/rust-learning-part4/" class="article-date">
  <time class="dt-published" datetime="2023-02-19T20:13:00.000Z" itemprop="datePublished">2023-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learning/">Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Rust 學習筆記第四章 - 結構體
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上次我們已經大略討論完 Rust 最重要的概念：所有權，<br>這次要討論的則是<strong>結構體（structure）</strong>，是很常見的資料結構。<br>如果學過 C&#x2F;C++ 大概會很有印象。</p>
<h2 id="結構體"><a href="#結構體" class="headerlink" title="結構體"></a>結構體</h2><p>結構體與元組類似，兩者都可以擁有多種數值，<br>但結構體的每個資料部份都需要被命名以表達意義；<br>這同時允許我們不用依賴資料的順序存取結構體實例的值。</p>
<p>如果要定義結構體，使用 <code>struct</code> 關鍵字並命名，<br>然後在 <code>&#123;&#125;</code> 內定義<strong>欄位（fields）</strong>，也就是每個資料部份的名稱與型別。<br>以下是一個簡單的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定義完結構體，接著就可以在其他地方建立擁有實際數值的<strong>實例（instance）</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我們對每個欄位指定實際的數值以建立一個實例；<br>若是實例可變，可以用 <code>.</code> 存取指定的欄位並賦值更改。<br>注意，整個實例可變才能更改單一欄位，Rust 不允許一個實例中僅有特定欄位被標記為可變。</p>
<p>另外如同表達式，函式本體最後的表達式可以回傳一個新的結構體實例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過這段的寫法有一個問題：函式參數名稱與結構體欄位名稱相同，重複太多了；<br>如果有更方便更簡潔的語法就更好了……</p>
<p>放心，Rust 會告訴你，「我當然有更好的方法囉。」</p>
<h3 id="欄位初始化簡寫"><a href="#欄位初始化簡寫" class="headerlink" title="欄位初始化簡寫"></a>欄位初始化簡寫</h3><p>當函式的參數名稱與結構體欄位相同，Rust 提供一種語法：<strong>欄位初始化簡寫（field init shorthand）</strong>，<br>能達到同樣的效果但不需要重複寫出相同的名稱：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣就可以省略重複的部份了，確實非常簡潔明瞭w</p>
<h3 id="結構體更新語法"><a href="#結構體更新語法" class="headerlink" title="結構體更新語法"></a>結構體更新語法</h3><p>有時候我們也會希望從現有的實例產生新的實例，並只修改一部分欄位，<br>這時候就可以使用<strong>結構體更新語法（struct update syntax）</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --省略--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>..user1</code> 是代表除了上一行指名的 <code>enail</code> 欄位以外，其他欄位使用與 <code>user1</code> 同樣的值。<br>你可能會注意到 <code>user2</code> 更新語法使用的是賦值的 <code>=</code>，<br>因為更新語法同樣會發生<strong>資料轉移</strong>（見<a href="../rust-learning-part2#%E7%A7%BB%E5%8B%95%EF%BC%88Move%EF%BC%89%E3%80%81%E8%A4%87%E8%A3%BD%EF%BC%88Clone%EF%BC%89%E3%80%81%E6%8B%B7%E8%B2%9D%EF%BC%88Copy%EF%BC%89">所有權篇</a>），這也代表 <code>user2</code> 建立之後，<code>user1</code> 便會失效。</p>
<h3 id="無名稱欄位元組結構體"><a href="#無名稱欄位元組結構體" class="headerlink" title="無名稱欄位元組結構體"></a>無名稱欄位元組結構體</h3><p>Rust 支援讓結構體長的像元組，稱之<strong>元組結構體（tuple structs）</strong>。<br>元組結構體的特徵是欄位<strong>沒有名稱、只有型別</strong>，<br>多用於命名不同型別的元組、或是不需要對結構體欄位命名時。</p>
<p>元組結構體同樣使用 <code>struct</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們會注意到儘管 <code>black</code> 跟 <code>origin</code> 的元素型別組成相同，但這兩者仍然是不同型別，<br>因為它們是不同型別的元組結構體實例；<br>另外元組結構體的使用方式與元組類似，可以解構成獨立的部份並透過索引存取。</p>
<h3 id="類單元結構體"><a href="#類單元結構體" class="headerlink" title="類單元結構體"></a>類單元結構體</h3><p>元組結構體是沒有欄位名稱，那如果連欄位都沒有還算是結構體嗎？<br>當然！Rust 有一種結構體是沒有任何欄位的，我們稱作<strong>類單元結構體（unit-like structs）</strong>。<br>類單元結構體的行為與單元型別類似，都是沒有任何除存在型別中的資料，<br>這樣的結構體通常用在實作<strong>特徵（trait，會在後面討論）</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：結構體資料仍然有所有權的概念，所以若是要在結構體內儲存資料引用，會需要<strong>生命週期（lifetime）</strong>的概念。）</p>
<p>學到這裡，我們可以透過一個簡單的範例專案理解結構體的使用。</p>
<h2 id="透過範例理解"><a href="#透過範例理解" class="headerlink" title="透過範例理解"></a>透過範例理解</h2><p>首先建立一個新專案 rectangles，這個專案會接收矩形的長寬，並計算面積。</p>
<h3 id="僅使用變數的狀況"><a href="#僅使用變數的狀況" class="headerlink" title="僅使用變數的狀況"></a>僅使用變數的狀況</h3><p>先按照下面的程式碼撰寫主程式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width1</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">height1</span> = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;長方形的面積為 &#123;&#125; 平方像素。&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(width1, height1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著編譯執行（<code>cargo run</code>），應該能得到正確的輸出；<br>這是一個邏輯正確的程式，但顯然不夠乾淨與明確，<br>首先從函式簽名就可以看到問題：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>area</code> 應該計算矩形面積，但參數名稱與矩形的關聯卻非常不明顯。<br>或許我們可以把長、寬組合起來？</p>
<h3 id="使用元組重構的情況"><a href="#使用元組重構的情況" class="headerlink" title="使用元組重構的情況"></a>使用元組重構的情況</h3><p>我們先用元組重構：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = (<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;長方形的面積為 &#123;&#125; 平方像素。&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(dimensions: (<span class="type">u32</span>, <span class="type">u32</span>)) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    dimensions.<span class="number">0</span> * dimensions.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們會發現元組只需要傳遞一個引數，而且引數非常明確是想要計算的矩形；<br>但同時你會發現閱讀性反而更差了，因為函式內部使用了元組的元素，<br>而元組有個弱點：<strong>元組無法對元素命名，只有索引</strong>。</p>
<p>我曾經在 <a href="../coding-style">Coding Style</a> 的文章談過，<br>一段好的程式碼是讓別人也看得懂，才有辦法進行協作與維護；<br>若是整個程式碼充斥著無意義的變數名稱與索引，那閱讀起來就非常吃力。</p>
<p>所以我們還有什麼方法可以讓函數的參數擁有意義、內部的函式本體也能建立關聯？<br>這就是結構體的用處了。</p>
<h3 id="使用結構體重構"><a href="#使用結構體重構" class="headerlink" title="使用結構體重構"></a>使用結構體重構</h3><p>現在讓我們用剛剛學到的結構體語法重構函式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;長方形的面積為 &#123;&#125; 平方像素。&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我們定義了一個 <code>Rectangle</code> 結構體，<br>另外有一個 <code>area</code> 函式需要參數 <code>rectangle</code>，型別是上述結構體的不可變借用；<br>使用借用是因為我們不希望取走實例的所有權，讓 <code>main</code> 可以繼續使用。</p>
<p>如此一來，我們便有一個清楚表達各數值關係的程式了。</p>
<h3 id="使用推導特徵實現更多功能"><a href="#使用推導特徵實現更多功能" class="headerlink" title="使用推導特徵實現更多功能"></a>使用推導特徵實現更多功能</h3><p>一般我們在 debug 的時候會利用標準輸出的方式去檢視數值，<br>但是在 Rust 自定義的結構體並不能這麼做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程式在編譯時便會出錯：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn<span class="string">&#x27;t implement `std::fmt::Display`</span></span><br></pre></td></tr></table></figure>
<p>因為要能被 <code>println!</code> 印出必須擁有 <code>Display</code> 特徵。</p>
<p>為了正常輸出，我們可以指定 <code>Debug</code> 特徵輸出格式如 <code>println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);</code>，<br>不過這樣仍然會得到錯誤，因為我們的結構體沒有顯式實作 <code>Debug</code> 特徵，<br>所以需要加上屬性來修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便可以編譯並執行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.1.0 (file:///projects/rectangles)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.48s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span><br></pre></td></tr></table></figure>
<p>但這樣輸出不好看，若是結構體成長起來會很麻煩，<br>所以我們會這樣修改 <code>println!</code>：<code>println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);</code><br>便能得到以下輸出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.1.0 (file:///projects/rectangles)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.48s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">rect1 is Rectangle &#123;</span><br><span class="line">    width: 30,</span><br><span class="line">    height: 50,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我們也可以使用 <code>dbg!</code> 這個巨集，<br>但會拿走表達式的所有權（<code>println!</code> 只使用引用）並且將訊息顯示到 <code>stderr</code>，<br>印出的是呼叫的檔案與行數：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>30 * scale</code> 我們也使用 <code>dbg!</code> 是因為 <code>dbg!</code> 會回傳所有權，<br>所以我們可以取得相同的數值；<br>另外我們不希望 <code>dbg!</code> 取走 <code>rect1</code> 的所有權，所以呼叫時加上引用，<br>會得到這樣的輸出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rectangles v0.1.0 (file:///projects/rectangles)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.61s</span><br><span class="line">     Running `target/debug/rectangles`</span><br><span class="line">[src/main.rs:10] 30 * scale = 60</span><br><span class="line">[src/main.rs:14] &amp;rect1 = Rectangle &#123;</span><br><span class="line">    width: 60,</span><br><span class="line">    height: 50,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，我們發現 <code>dbg!</code> 是非常實用的一種輸出方式！</p>
<p>我們完成了 <code>area</code> 函式，並且確認它只會計算矩形面積，<br>那如果我們能把這樣的行為與結構體綁定呢？</p>
<h2 id="方法語法"><a href="#方法語法" class="headerlink" title="方法語法"></a>方法語法</h2><p>關於上面的問題，有一個很好的方案可以解決：<strong>方法（method）</strong>。</p>
<p>方法與函式類似，也是透過 <code>fn</code> 宣告，但方法是特別針對結構體定義的。<br>我們先來嘗試修改 <code>area</code> 作為 <code>Rectangle</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;長方形的面積為 &#123;&#125; 平方像素。&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這裡有幾個需要注意的部份：</p>
<h4 id="1-impl-Rectangle"><a href="#1-impl-Rectangle" class="headerlink" title="1. impl Rectangle"></a>1. <code>impl Rectangle</code></h4><p>這是要實作結構體方法的宣告方式，<code>impl</code> 代表 <strong>implementation</strong>，<br>在這個區塊內所有的方法都會與指定的結構體有關。</p>
<h4 id="2-fn-area-amp-self"><a href="#2-fn-area-amp-self" class="headerlink" title="2. fn area(&amp;self)"></a>2. <code>fn area(&amp;self)</code></h4><p>注意到參數是 <code>&amp;self</code>，如果寫過 Java、Python 的物件會很熟悉，<br>這個東西是 <code>self: &amp;Self</code> 的簡寫，指的是呼叫的結構體實例。<br>**所有結構體方法的第一個參數都應該是 <code>self</code>**；<br>另外，這裡使用借用是因為我們不希望失去所有權，這在前面討論所有權時已經說明過了。</p>
<p>除了另外定義，我們也可以把結構體的欄位當作方法的名稱：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;長方形的寬度不為零，而是 &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊我們把 <code>width</code> 同時作為方法，判斷是否大於 0；<br>在 <code>main</code> 中當我們呼叫 <code>width</code> 時，若是後面跟隨 <code>()</code> 就是呼叫方法，反之則是呼叫欄位。</p>
<p>不過一般而言，我們使用欄位名稱作為方法時，通常希望回傳欄位的數值，<br>這被稱作 <strong>getter</strong>，並且常常將欄位隱藏起來，這跟 public 與 private有關。</p>
<h3 id="關聯函式"><a href="#關聯函式" class="headerlink" title="關聯函式"></a>關聯函式</h3><p>在 <code>impl</code> 區塊內的所有方法都是<strong>關聯函式（associated funtion）</strong>，因為會與結構體相關；<br>但若是不需要型別實例的話，可以定義沒有 <code>self</code> 作為第一個參數的函式，<br>這種關聯函式就不是方法（因為沒有方法實例）。</p>
<p>沒有方法實例的關聯函式常用於作為建構子產生新實例，<br>在 Java 有指定的關鍵字 <code>new</code>，但在 Rust 並沒有這樣的內建關鍵字，<br>所以可以自行指定建構子函式的名稱。</p>
<p>呼叫關聯函式的方式是在結構體名稱後使用 <code>::</code> 呼叫函式，<br>這時結構體名稱會被作為<strong>命名空間</strong>。（命名空間會在後續討論）</p>
<h3 id="多重-impl"><a href="#多重-impl" class="headerlink" title="多重 impl"></a>多重 <code>impl</code></h3><p>每個結構體都被允許擁有多個 <code>impl</code> 區塊，一般多半用於<strong>泛型</strong>（會在後面討論）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>結構體在 Rust 中是非常實用的語法，能自己定義需要且有意義的型別，<br>也能夠定義實用的方法、關聯函式，指定結構體可以有什麼行為。</p>
<p>這次結構體相對很容易理解，加上如果有寫物件導向的經驗，會更容易上手。<br>下一篇我們就要來談談另一個自訂型別的好方法————<strong>枚舉</strong>。</p>
<p>火山 &#x2F; Kazan<br>2023.02.22</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kazan.tw/posts/rust-learning-part4/" data-id="clgdh2q4h000wcyr2erwf1hg0" data-title="Rust 學習筆記第四章 - 結構體" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/kde-plasma-vs-gnome/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          KDE Plasma vs GNOME —— 桌面環境使用心得
        
      </div>
    </a>
  
  
    <a href="/posts/rust-learning-part3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Rust 學習筆記第三章 - 所有權（下）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分類</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Learning/">Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux-distros/">Linux distros</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technical/">Technical</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utils/">Utils</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technical/">technical</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">標籤</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arch/" rel="tag">Arch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DE/" rel="tag">DE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Editors/" rel="tag">Editors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GNOME/" rel="tag">GNOME</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KDE-Plasma/" rel="tag">KDE Plasma</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSP/" rel="tag">LSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Neovim/" rel="tag">Neovim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Plug-ins/" rel="tag">Plug-ins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VM/" rel="tag">VM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coding/" rel="tag">coding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/infra/" rel="tag">infra</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">標籤雲</h3>
    <div class="widget tagcloud">
      <a href="/tags/Arch/" style="font-size: 16.67px;">Arch</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/DE/" style="font-size: 10px;">DE</a> <a href="/tags/Data-Structure/" style="font-size: 13.33px;">Data Structure</a> <a href="/tags/Editors/" style="font-size: 13.33px;">Editors</a> <a href="/tags/GNOME/" style="font-size: 10px;">GNOME</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/KDE-Plasma/" style="font-size: 10px;">KDE Plasma</a> <a href="/tags/LSP/" style="font-size: 10px;">LSP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Neovim/" style="font-size: 13.33px;">Neovim</a> <a href="/tags/Plug-ins/" style="font-size: 10px;">Plug-ins</a> <a href="/tags/Rust/" style="font-size: 20px;">Rust</a> <a href="/tags/VM/" style="font-size: 13.33px;">VM</a> <a href="/tags/coding/" style="font-size: 10px;">coding</a> <a href="/tags/infra/" style="font-size: 13.33px;">infra</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">彙整</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/update-notifaction/">網站改版通知</a>
          </li>
        
          <li>
            <a href="/posts/kde-plasma-vs-gnome/">KDE Plasma vs GNOME —— 桌面環境使用心得</a>
          </li>
        
          <li>
            <a href="/posts/rust-learning-part4/">Rust 學習筆記第四章 - 結構體</a>
          </li>
        
          <li>
            <a href="/posts/rust-learning-part3/">Rust 學習筆記第三章 - 所有權（下）</a>
          </li>
        
          <li>
            <a href="/posts/rust-learning-part2/">Rust 學習筆記第二章 - 所有權（上）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Kazan @ Kazan Studio<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/cal" class="mobile-nav-link">Calender</a>
  
    <a href="/contact" class="mobile-nav-link">Contact</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>